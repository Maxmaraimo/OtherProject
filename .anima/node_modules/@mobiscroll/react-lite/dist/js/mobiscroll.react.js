(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('react-dom'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['react', 'react-dom', 'prop-types'], factory) :
  (global = global || self, global.mobiscroll = factory(global.React, global.ReactDOM, global.PropTypes));
}(this, (function (React, ReactDOM, PropTypes) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;
  ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;
  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var mobiscroll = mobiscroll || {},
      util = {};

  var os,
      vers,
      majorVersion,
      minorVersion,
      version = [],
      isBrowser = typeof window !== 'undefined',
      isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,
      userAgent = isBrowser ? navigator.userAgent : '',
      platform = isBrowser ? navigator.platform : '',
      maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,
      isSafari = /Safari/.test(userAgent),
      device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),
      raf = isBrowser && window.requestAnimationFrame || function (func) {
    return setTimeout(func, 20);
  };

  if (/Android/i.test(device)) {
    os = 'android';
    vers = userAgent.match(/Android\s+([\d.]+)/i);

    if (vers) {
      version = vers[0].replace('Android ', '').split('.');
    }
  } else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {
    // On iPad with iOS 13 desktop site request is automatically enabled in Safari,
    // so 'iPad' is no longer present in the user agent string.
    // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.
    // maxTouchPoints is needed to exclude desktop Mac OS X.
    os = 'ios';
    vers = userAgent.match(/OS\s+([\d_]+)/i);

    if (vers) {
      version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
    }
  } else if (/Windows Phone/i.test(device)) {
    os = 'wp';
  } else if (/Windows|MSIE/i.test(device)) {
    os = 'windows';
  }

  majorVersion = version[0];
  minorVersion = version[1];

  function testProps(props) {
    var i;

    for (i in props) {
      if (mod[props[i]] !== undefined) {
        return true;
      }
    }

    return false;
  }

  function testPrefix() {
    var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
        p;

    for (p in prefixes) {
      if (testProps([prefixes[p] + 'Transform'])) {
        return '-' + prefixes[p].toLowerCase() + '-';
      }
    }

    return '';
  }

  function testTouch(e, elm) {
    if (e.type == 'touchstart') {
      elm.__mbscTouched = 1;
    } else if (elm.__mbscTouched) {
      delete elm.__mbscTouched;
      return false;
    }

    return true;
  }

  function listen(el, event, handler, opt) {
    if (el) {
      el.addEventListener(event, handler, opt);
    }
  }

  function unlisten(el, event, handler, opt) {
    if (el) {
      el.removeEventListener(event, handler, opt);
    }
  }

  function matches(element, selector) {
    if (!selector || !element || element.nodeType !== 1) {
      return false;
    }

    var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;
    return matchesSelector.call(element, selector);
  }

  function closest(el, target, selector) {
    while (target) {
      if (matches(target, selector)) {
        return target;
      }

      target = target !== el ? target.parentNode : null;
    }

    return null;
  }

  function trigger(elm, name, data) {
    var evt;

    try {
      evt = new CustomEvent(name, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } catch (e) {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
      evt.detail = data;
    }

    elm.dispatchEvent(evt);
  }

  var animEnd,
      canvas,
      mod,
      cssPrefix,
      hasGhostClick,
      hasTransition,
      isWebView,
      isWkWebView,
      jsPrefix,
      win;

  if (isBrowser) {
    win = window;
    canvas = document.createElement('canvas');
    mod = document.createElement('modernizr').style;
    cssPrefix = testPrefix();
    jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');
    animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
    hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, 
    // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView
    // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs
    // (keyboard appears, but the cursor is not in the input).

    isWebView = os === 'ios' && !isSafari;
    isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;
    hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;
  }

  var cssNumber = {
    'column-count': 1,
    'columns': 1,
    'font-weight': 1,
    'line-height': 1,
    'opacity': 1,
    'z-index': 1,
    'zoom': 1
  },
      propMap = {
    'readonly': 'readOnly'
  },
      emptyArray = [],
      _slice = Array.prototype.slice;

  function isFunction(value) {
    return typeof value === "function";
  }

  function isObject(obj) {
    return typeof obj === "object";
  }

  function likeArray(obj) {
    return typeof obj.length == 'number';
  }

  function camelize(str) {
    return str.replace(/-+(.)?/g, function (match, chr) {
      return chr ? chr.toUpperCase() : '';
    });
  }

  function extend(target, source, deep) {
    for (var key in source) {
      if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {
        if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {
          target[key] = {};
        }

        extend(target[key], source[key], deep);
      } else if (source[key] !== undefined) {
        target[key] = source[key];
      }
    }
  }

  function dasherize(str) {
    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  }

  function maybeAddPx(name, value) {
    return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
  }

  var Dom = function () {
    var Dom = function Dom(arr) {
      var _this = this,
          i = 0; // Create array-like object


      for (i = 0; i < arr.length; i++) {
        _this[i] = arr[i];
      }

      _this.length = arr.length; // Return collection with methods

      return $(this);
    };

    var $ = function $(selector, context) {
      var arr = [],
          i = 0;

      if (selector && !context) {
        if (selector instanceof Dom) {
          return selector;
        }
      }

      if (isFunction(selector)) {
        return $(document).ready(selector);
      }

      if (selector) {
        // String
        if (typeof selector === 'string') {
          var els, tempParent, html;
          selector = html = selector.trim();

          if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
            var toCreate = 'div';

            if (html.indexOf('<li') === 0) {
              toCreate = 'ul';
            }

            if (html.indexOf('<tr') === 0) {
              toCreate = 'tbody';
            }

            if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
              toCreate = 'tr';
            }

            if (html.indexOf('<tbody') === 0) {
              toCreate = 'table';
            }

            if (html.indexOf('<option') === 0) {
              toCreate = 'select';
            }

            tempParent = document.createElement(toCreate);
            tempParent.innerHTML = html;

            for (i = 0; i < tempParent.childNodes.length; i++) {
              arr.push(tempParent.childNodes[i]);
            }
          } else {
            if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
              // Pure ID selector
              els = [document.getElementById(selector.split('#')[1])];
            } else {
              if (context instanceof Dom) {
                context = context[0];
              } // Other selectors


              els = (context || document).querySelectorAll(selector);
            }

            for (i = 0; i < els.length; i++) {
              if (els[i]) {
                arr.push(els[i]);
              }
            }
          }
        } // Node/element
        else if (selector.nodeType || selector === window || selector === document) {
            arr.push(selector);
          } //Array of elements or instance of Dom
          else if (selector.length > 0 && selector[0].nodeType) {
              for (i = 0; i < selector.length; i++) {
                arr.push(selector[i]);
              }
            } else if ($.isArray(selector)) {
              arr = selector;
            }
      }

      return new Dom(arr);
    };

    Dom.prototype = {
      ready: function ready(callback) {
        if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
          callback($);
        } else {
          document.addEventListener('DOMContentLoaded', function () {
            callback($);
          }, false);
        }

        return this;
      },
      concat: emptyArray.concat,
      empty: function empty() {
        return this.each(function () {
          this.innerHTML = '';
        });
      },
      map: function map(fn) {
        return $($.map(this, function (el, i) {
          return fn.call(el, i, el);
        }));
      },
      slice: function slice() {
        return $(_slice.apply(this, arguments));
      },
      // Classes and attriutes
      // NOTE: element.classList attribure is not supported on android 2.3!!!
      addClass: function addClass(className) {
        if (typeof className === 'undefined') {
          return this;
        }

        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i++) {
          for (var j = 0; j < this.length; j++) {
            if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
              this[j].classList.add(classes[i]);
            }
          }
        }

        return this;
      },
      removeClass: function removeClass(className) {
        if (typeof className === 'undefined') {
          return this;
        }

        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i++) {
          for (var j = 0; j < this.length; j++) {
            if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
              this[j].classList.remove(classes[i]);
            }
          }
        }

        return this;
      },
      hasClass: function hasClass(className) {
        return this[0] ? this[0].classList.contains(className) : false;
      },
      toggleClass: function toggleClass(className) {
        var classes = className.split(' ');

        for (var i = 0; i < classes.length; i++) {
          for (var j = 0; j < this.length; j++) {
            if (typeof this[j].classList !== 'undefined') {
              this[j].classList.toggle(classes[i]);
            }
          }
        }

        return this;
      },
      closest: function closest(selector, context) {
        var node = this[0],
            collection = false;

        if (isObject(selector)) {
          collection = $(selector);
        }

        while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
          node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
        }

        return $(node);
      },
      attr: function attr(attrs, value) {
        var attr;

        if (arguments.length === 1 && typeof attrs === 'string') {
          // Get attr
          if (this.length) {
            attr = this[0].getAttribute(attrs);
            return attr || attr === '' ? attr : undefined;
          }
        } else {
          // Set attrs
          for (var i = 0; i < this.length; i++) {
            if (arguments.length === 2) {
              // String
              this[i].setAttribute(attrs, value);
            } else {
              // Object
              for (var attrName in attrs) {
                this[i][attrName] = attrs[attrName];
                this[i].setAttribute(attrName, attrs[attrName]);
              }
            }
          }

          return this;
        }
      },
      removeAttr: function removeAttr(attr) {
        for (var i = 0; i < this.length; i++) {
          this[i].removeAttribute(attr);
        }

        return this;
      },
      prop: function prop(props, value) {
        props = propMap[props] || props;

        if (arguments.length === 1 && typeof props === 'string') {
          // Get prop
          return this[0] ? this[0][props] : undefined;
        } else {
          // Set props
          for (var i = 0; i < this.length; i++) {
            this[i][props] = value;
          }

          return this;
        }
      },
      val: function val(value) {
        if (typeof value === 'undefined') {
          if (this.length && this[0].multiple) {
            return $.map(this.find('option:checked'), function (v) {
              return v.value;
            });
          }

          return this[0] ? this[0].value : undefined;
        }

        if (this.length && this[0].multiple) {
          $.each(this[0].options, function () {
            this.selected = value.indexOf(this.value) != -1;
          });
        } else {
          for (var i = 0; i < this.length; i++) {
            this[i].value = value;
          }
        }

        return this;
      },
      //Events
      on: function on(eventName, targetSelector, listener, capture) {
        var boundListener,
            elm,
            event,
            events = eventName.split(' '),
            i,
            j;

        function handleLiveEvent(e) {
          var target = e.target;

          while (target) {
            if ($(target).is(targetSelector)) {
              listener.call(target, e);
            }

            target = target !== this ? target.parentNode : null;
          }
        }

        function handleNamespaces(el, name, listener, capture) {
          var namespace = name.split('.');

          if (!el.DomNameSpaces) {
            el.DomNameSpaces = [];
          }

          el.DomNameSpaces.push({
            namespace: namespace[1],
            event: namespace[0],
            listener: listener,
            capture: capture
          });
          el.addEventListener(namespace[0], listener, capture);
        }

        for (i = 0; i < this.length; i++) {
          elm = this[i];

          if (isFunction(targetSelector) || targetSelector === false) {
            // Usual events
            if (isFunction(targetSelector)) {
              capture = listener || false;
              listener = targetSelector;
            }

            for (j = 0; j < events.length; j++) {
              event = events[j]; // check for namespaces

              if (event.indexOf('.') != -1) {
                handleNamespaces(elm, event, listener, capture);
              } else {
                elm.addEventListener(event, listener, capture);
              }
            }
          } else {
            // Live events
            boundListener = handleLiveEvent.bind(elm);

            for (j = 0; j < events.length; j++) {
              event = events[j];

              if (!elm.DomLiveListeners) {
                elm.DomLiveListeners = [];
              }

              elm.DomLiveListeners.push({
                listener: listener,
                liveListener: boundListener
              });

              if (event.indexOf('.') != -1) {
                handleNamespaces(elm, event, boundListener, capture);
              } else {
                elm.addEventListener(event, boundListener, capture);
              }
            }
          }
        }

        return this;
      },
      off: function off(eventName, targetSelector, listener, capture) {
        var elm,
            event,
            events,
            i,
            j,
            k,
            liveListeners,
            that = this;

        function removeEvents(event) {
          var el,
              i,
              j,
              item,
              nameSpaces,
              parts = event.split('.'),
              name = parts[0],
              ns = parts[1];

          for (i = 0; i < that.length; ++i) {
            el = that[i];
            nameSpaces = el.DomNameSpaces;

            if (nameSpaces) {
              for (j = 0; j < nameSpaces.length; ++j) {
                item = nameSpaces[j];

                if (item.namespace == ns && (item.event == name || !name)) {
                  el.removeEventListener(item.event, item.listener, item.capture);
                  item.removed = true;
                }
              } // remove the events from the DomNameSpaces array


              for (j = nameSpaces.length - 1; j >= 0; --j) {
                if (nameSpaces[j].removed) {
                  nameSpaces.splice(j, 1);
                }
              }
            }
          }
        }

        events = eventName.split(' ');

        for (i = 0; i < events.length; i++) {
          event = events[i];

          for (j = 0; j < this.length; j++) {
            elm = this[j];
            liveListeners = elm.DomLiveListeners;

            if (isFunction(targetSelector) || targetSelector === false) {
              // Usual events
              if (isFunction(targetSelector)) {
                capture = listener || false;
                listener = targetSelector;
              }

              if (event.indexOf('.') === 0) {
                // remove namespace events
                removeEvents(event.substr(1));
              } else {
                elm.removeEventListener(event, listener, capture);
              }
            } else {
              // Live event
              if (liveListeners) {
                for (k = 0; k < liveListeners.length; k++) {
                  if (liveListeners[k].listener === listener) {
                    elm.removeEventListener(event, liveListeners[k].liveListener, capture);
                  }
                }
              }

              if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {
                removeEvents(event);
              }
            }
          }
        }

        return this;
      },
      trigger: function trigger$1(eventName, eventData) {
        var events = eventName.split(' ');

        for (var i = 0; i < events.length; i++) {
          for (var j = 0; j < this.length; j++) {
            trigger(this[j], events[i], eventData);
          }
        }

        return this;
      },
      // Sizing/Styles
      width: function width(dim) {
        if (dim !== undefined) {
          return this.css('width', dim);
        }

        if (this[0] === window) {
          return window.innerWidth;
        } else if (this[0] === document) {
          return document.documentElement.scrollWidth;
        } else {
          return this.length > 0 ? parseFloat(this.css('width')) : null;
        }
      },
      height: function height(dim) {
        if (dim !== undefined) {
          return this.css('height', dim);
        }

        if (this[0] === window) {
          return window.innerHeight;
        } else if (this[0] === document) {
          var body = document.body,
              html = document.documentElement;
          return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
        } else {
          return this.length > 0 ? parseFloat(this.css('height')) : null;
        }
      },
      innerWidth: function innerWidth() {
        var elm = this;

        if (this.length > 0) {
          if (this[0].innerWidth) {
            return this[0].innerWidth;
          } else {
            var size = this[0].offsetWidth,
                sides = ['left', 'right'];
            sides.forEach(function (side) {
              size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
            });
            return size;
          }
        }
      },
      innerHeight: function innerHeight() {
        var elm = this;

        if (this.length > 0) {
          if (this[0].innerHeight) {
            return this[0].innerHeight;
          } else {
            var size = this[0].offsetHeight,
                sides = ['top', 'bottom'];
            sides.forEach(function (side) {
              size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
            });
            return size;
          }
        }
      },
      offset: function offset() {
        if (this.length > 0) {
          var el = this[0],
              box = el.getBoundingClientRect(),
              doc = document.documentElement;
          return {
            top: box.top + window.pageYOffset - doc.clientTop,
            left: box.left + window.pageXOffset - doc.clientLeft
          };
        }
      },
      hide: function hide() {
        for (var i = 0; i < this.length; i++) {
          this[i].style.display = 'none';
        }

        return this;
      },
      show: function show() {
        for (var i = 0; i < this.length; i++) {
          if (this[i].style.display == "none") {
            this[i].style.display = '';
          }

          if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
            this[i].style.display = 'block';
          }
        }

        return this;
      },
      clone: function clone() {
        return this.map(function () {
          return this.cloneNode(true);
        });
      },
      styles: function styles() {
        return this[0] ? window.getComputedStyle(this[0], null) : undefined;
      },
      css: function css(property, value) {
        var i,
            key,
            element = this[0],
            css = '';

        if (arguments.length < 2) {
          if (!element) {
            return;
          }

          if (typeof property === 'string') {
            return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
          }
        }

        if (typeof property === 'string') {
          if (!value && value !== 0) {
            this.each(function () {
              this.style.removeProperty(dasherize(property));
            });
          } else {
            css = dasherize(property) + ":" + maybeAddPx(property, value);
          }
        } else {
          for (key in property) {
            if (!property[key] && property[key] !== 0) {
              for (i = 0; i < this.length; i++) {
                this[i].style.removeProperty(dasherize(key));
              }
            } else {
              css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
            }
          }
        }

        return this.each(function () {
          this.style.cssText += ';' + css;
        });
      },
      each: function each(callback) {
        for (var i = 0; i < this.length; i++) {
          if (callback.apply(this[i], [i, this[i]]) === false) {
            break;
          }
        }

        return this;
      },
      filter: function filter(callback) {
        var matchedItems = [];

        for (var i = 0; i < this.length; i++) {
          if (isFunction(callback)) {
            if (callback.call(this[i], i, this[i])) {
              matchedItems.push(this[i]);
            }
          } else if (matches(this[i], callback)) {
            matchedItems.push(this[i]);
          }
        }

        return new Dom(matchedItems);
      },
      html: function html(_html) {
        if (typeof _html === 'undefined') {
          return this[0] ? this[0].innerHTML : undefined;
        } else {
          this.empty();

          for (var i = 0; i < this.length; i++) {
            this[i].innerHTML = _html;
          }

          return this;
        }
      },
      text: function text(_text) {
        if (typeof _text === 'undefined') {
          return this[0] ? this[0].textContent.trim() : null;
        } else {
          for (var i = 0; i < this.length; i++) {
            this[i].textContent = _text;
          }

          return this;
        }
      },
      is: function is(selector) {
        return this.length > 0 && matches(this[0], selector);
      },
      not: function not(selector) {
        var nodes = [];

        if (isFunction(selector) && selector.call !== undefined) {
          this.each(function (idx) {
            if (!selector.call(this, idx)) {
              nodes.push(this);
            }
          });
        } else {
          var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

          if (isObject(excludes)) {
            excludes = $.map(excludes, function (el) {
              return el;
            });
          }

          this.each(function (i, el) {
            if (excludes.indexOf(el) < 0) {
              nodes.push(el);
            }
          });
        }

        return $(nodes);
      },
      indexOf: function indexOf(el) {
        for (var i = 0; i < this.length; i++) {
          if (this[i] === el) {
            return i;
          }
        }
      },
      index: function index(element) {
        return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
      },
      get: function get(idx) {
        return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
      },
      eq: function eq(index) {
        if (typeof index === 'undefined') {
          return this;
        }

        var length = this.length,
            returnIndex;

        if (index > length - 1) {
          return new Dom([]);
        }

        if (index < 0) {
          returnIndex = length + index;
          return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
        }

        return new Dom([this[index]]);
      },
      append: function append(newChild) {
        var i, j;

        for (i = 0; i < this.length; i++) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom) {
            for (j = 0; j < newChild.length; j++) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }

        return this;
      },
      appendTo: function appendTo(parent) {
        $(parent).append(this);
        return this;
      },
      prepend: function prepend(newChild) {
        var i, j;

        for (i = 0; i < this.length; i++) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
              this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
            } // this[i].insertAdjacentHTML('afterbegin', newChild);

          } else if (newChild instanceof Dom) {
            for (j = 0; j < newChild.length; j++) {
              this[i].insertBefore(newChild[j], this[i].childNodes[0]);
            }
          } else {
            this[i].insertBefore(newChild, this[i].childNodes[0]);
          }
        }

        return this;
      },
      prependTo: function prependTo(parent) {
        $(parent).prepend(this);
        return this;
      },
      insertBefore: function insertBefore(selector) {
        var before = $(selector);

        for (var i = 0; i < this.length; i++) {
          if (before.length === 1) {
            before[0].parentNode.insertBefore(this[i], before[0]);
          } else if (before.length > 1) {
            for (var j = 0; j < before.length; j++) {
              before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
            }
          }
        }

        return this;
      },
      insertAfter: function insertAfter(selector) {
        var after = $(selector);

        for (var i = 0; i < this.length; i++) {
          if (after.length === 1) {
            after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
          } else if (after.length > 1) {
            for (var j = 0; j < after.length; j++) {
              after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
            }
          }
        }

        return this;
      },
      next: function next(selector) {
        if (this.length > 0) {
          if (selector) {
            if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
              return new Dom([this[0].nextElementSibling]);
            } else {
              return new Dom([]);
            }
          } else {
            if (this[0].nextElementSibling) {
              return new Dom([this[0].nextElementSibling]);
            } else {
              return new Dom([]);
            }
          }
        } else {
          return new Dom([]);
        }
      },
      nextAll: function nextAll(selector) {
        var nextEls = [],
            el = this[0];

        if (!el) {
          return new Dom([]);
        }

        while (el.nextElementSibling) {
          var next = el.nextElementSibling;

          if (selector) {
            if ($(next).is(selector)) {
              nextEls.push(next);
            }
          } else {
            nextEls.push(next);
          }

          el = next;
        }

        return new Dom(nextEls);
      },
      prev: function prev(selector) {
        if (this.length > 0) {
          if (selector) {
            if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
              return new Dom([this[0].previousElementSibling]);
            } else {
              return new Dom([]);
            }
          } else {
            if (this[0].previousElementSibling) {
              return new Dom([this[0].previousElementSibling]);
            } else {
              return new Dom([]);
            }
          }
        } else {
          return new Dom([]);
        }
      },
      prevAll: function prevAll(selector) {
        var prevEls = [];
        var el = this[0];

        if (!el) {
          return new Dom([]);
        }

        while (el.previousElementSibling) {
          var prev = el.previousElementSibling;

          if (selector) {
            if ($(prev).is(selector)) {
              prevEls.push(prev);
            }
          } else {
            prevEls.push(prev);
          }

          el = prev;
        }

        return new Dom(prevEls);
      },
      parent: function parent(selector) {
        var parents = [];

        for (var i = 0; i < this.length; i++) {
          if (this[i].parentNode !== null) {
            if (selector) {
              if ($(this[i].parentNode).is(selector)) {
                parents.push(this[i].parentNode);
              }
            } else {
              parents.push(this[i].parentNode);
            }
          }
        }

        return $($.unique(parents));
      },
      parents: function parents(selector) {
        var parents = [];

        for (var i = 0; i < this.length; i++) {
          var parent = this[i].parentNode;

          while (parent) {
            if (selector) {
              if ($(parent).is(selector)) {
                parents.push(parent);
              }
            } else {
              parents.push(parent);
            }

            parent = parent.parentNode;
          }
        }

        return $($.unique(parents));
      },
      find: function find(selector) {
        var foundElements = [];

        for (var i = 0; i < this.length; i++) {
          var found = this[i].querySelectorAll(selector);

          for (var j = 0; j < found.length; j++) {
            foundElements.push(found[j]);
          }
        }

        return new Dom(foundElements);
      },
      children: function children(selector) {
        var children = [];

        for (var i = 0; i < this.length; i++) {
          var childNodes = this[i].childNodes;

          for (var j = 0; j < childNodes.length; j++) {
            if (!selector) {
              if (childNodes[j].nodeType === 1) {
                children.push(childNodes[j]);
              }
            } else {
              if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                children.push(childNodes[j]);
              }
            }
          }
        }

        return new Dom($.unique(children));
      },
      remove: function remove() {
        for (var i = 0; i < this.length; i++) {
          if (this[i].parentNode) {
            this[i].parentNode.removeChild(this[i]);
          }
        }

        return this;
      },
      add: function add() {
        var dom = this;
        var i, j;

        for (i = 0; i < arguments.length; i++) {
          var toAdd = $(arguments[i]);

          for (j = 0; j < toAdd.length; j++) {
            dom[dom.length] = toAdd[j];
            dom.length++;
          }
        }

        return dom;
      },
      before: function before(elm) {
        $(elm).insertBefore(this);
        return this;
      },
      after: function after(elm) {
        $(elm).insertAfter(this);
        return this;
      },
      scrollTop: function scrollTop(value) {
        if (!this.length) {
          return;
        }

        var hasScrollTop = 'scrollTop' in this[0];

        if (value === undefined) {
          return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
        }

        return this.each(hasScrollTop ? function () {
          this.scrollTop = value;
        } : function () {
          this.scrollTo(this.scrollX, value);
        });
      },
      scrollLeft: function scrollLeft(value) {
        if (!this.length) {
          return;
        }

        var hasScrollLeft = 'scrollLeft' in this[0];

        if (value === undefined) {
          return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
        }

        return this.each(hasScrollLeft ? function () {
          this.scrollLeft = value;
        } : function () {
          this.scrollTo(value, this.scrollY);
        });
      },
      contents: function contents() {
        return this.map(function (i, v) {
          return _slice.call(v.childNodes);
        });
      },
      nextUntil: function nextUntil(selector) {
        var n = this,
            array = [];

        while (n.length && !n.filter(selector).length) {
          array.push(n[0]);
          n = n.next();
        }

        return $(array);
      },
      prevUntil: function prevUntil(selector) {
        var n = this,
            array = [];

        while (n.length && !$(n).filter(selector).length) {
          array.push(n[0]);
          n = n.prev();
        }

        return $(array);
      },
      detach: function detach() {
        return this.remove();
      }
    }; // Link to prototype

    $.fn = Dom.prototype;
    return $;
  }(); // Export to local scope


  var $ = Dom; // Export to mobiscroll

  mobiscroll.$ = Dom; // DOM Library Utilites

  $.inArray = function (elem, array, i) {
    return emptyArray.indexOf.call(array, elem, i);
  };

  $.extend = function (target) {
    var deep,
        args = _slice.call(arguments, 1);

    if (typeof target == 'boolean') {
      deep = target;
      target = args.shift();
    }

    target = target || {};
    args.forEach(function (arg) {
      extend(target, arg, deep);
    });
    return target;
  };

  $.isFunction = isFunction;

  $.isArray = function (arr) {
    return Object.prototype.toString.apply(arr) === '[object Array]';
  };

  $.isPlainObject = function (obj) {
    return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
  };

  $.each = function (obj, callback) {
    var i, prop;

    if (!isObject(obj) || !callback) {
      return;
    }

    if ($.isArray(obj) || obj instanceof Dom) {
      // Array
      for (i = 0; i < obj.length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      // Object
      for (prop in obj) {
        // eslint-disable-next-line no-prototype-builtins
        if (obj.hasOwnProperty(prop) && prop !== 'length') {
          if (callback.call(obj[prop], prop, obj[prop]) === false) {
            break;
          }
        }
      }
    }

    return this;
  };

  $.unique = function (arr) {
    var unique = [];

    for (var i = 0; i < arr.length; i++) {
      if (unique.indexOf(arr[i]) === -1) {
        unique.push(arr[i]);
      }
    }

    return unique;
  };

  $.map = function (elements, callback) {
    var value,
        values = [],
        i,
        key;

    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i);

        if (value !== null) {
          values.push(value);
        }
      }
    } else {
      for (key in elements) {
        value = callback(elements[key], key);

        if (value !== null) {
          values.push(value);
        }
      }
    }

    return values.length > 0 ? $.fn.concat.apply([], values) : values;
  };

  function noop() {}

  function isString(s) {
    return typeof s === 'string';
  }

  function constrain(val, min, max) {
    return Math.max(min, Math.min(val, max));
  }

  function vibrate(time) {
    if ('vibrate' in navigator) {
      navigator.vibrate(time || 50);
    }
  }

  function getPercent(v, min, max) {
    return (v - min) * 100 / (max - min);
  }

  function getBoolAttr(attr, def, $elm) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : v === 'true';
  }

  var tapped = 0;
  var allowQuick;

  function preventClick() {
    // Prevent ghost click
    tapped++;
    setTimeout(function () {
      tapped--;
    }, 500);
  }

  function triggerClick(ev, control) {
    // Prevent duplicate triggers on the same element
    // e.g. a form checkbox inside a listview item
    if (control.mbscClick) {
      return;
    }

    var touch = (ev.originalEvent || ev).changedTouches[0],
        evt = document.createEvent('MouseEvents');
    evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    evt.isMbscTap = true; // Prevent ionic to bust our click
    // This works for Ionic 1 - 3, not sure about 4

    evt.isIonicTap = true; // This will allow a click fired together with this click
    // We need this, because clicking on a label will trigger a click
    // on the associated input as well, which should not be busted

    allowQuick = true;
    control.mbscChange = true;
    control.mbscClick = true;
    control.dispatchEvent(evt);
    allowQuick = false; // Prevent ghost click

    preventClick();
    setTimeout(function () {
      delete control.mbscClick;
    });
  }

  function getCoord(e, c, page) {
    var ev = e.originalEvent || e,
        prop = (page ? 'page' : 'client') + c; // Multi touch support

    if (ev.targetTouches && ev.targetTouches[0]) {
      return ev.targetTouches[0][prop];
    }

    if (ev.changedTouches && ev.changedTouches[0]) {
      return ev.changedTouches[0][prop];
    }

    return e[prop];
  }

  function getControlType($elm) {
    var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
    var elm = $elm[0];
    var role = $elm.attr('data-role');
    var type = $elm.attr('type') || elm.nodeName.toLowerCase();

    if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
      type = role;
    } else {
      for (var i = 0; i < attrs.length; i++) {
        if ($elm.is('[mbsc-' + attrs[i] + ']')) {
          type = attrs[i];
        }
      }
    }

    return type;
  }

  function activateControl(control, type, ev) {
    control.focus();

    if (/(button|submit|checkbox|switch|radio)/.test(type)) {
      ev.preventDefault();
    }

    if (!/select/.test(type)) {
      triggerClick(ev, control);
    }
  }

  function tap(that, el, handler, prevent, tolerance, time) {
    var startX,
        startY,
        target,
        moved,
        startTime,
        $ = mobiscroll.$,
        $elm = $(el);
    tolerance = tolerance || 9;

    function onStart(ev) {
      if (!target) {
        // Can't always call preventDefault here, it kills page scroll
        // if (prevent) {
        //     ev.preventDefault();
        // }
        target = this;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        moved = false;
        startTime = new Date();
      }
    }

    function onMove(ev) {
      // If movement is more than 20px, don't fire the click event handler
      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
        moved = true;
      }
    }

    function onEnd(ev) {
      if (target) {
        if (time && new Date() - startTime < 100 || !moved) {
          // ev.preventDefault();
          // handler.call(target, ev, that);
          triggerClick(ev, ev.target);
        } else {
          preventClick();
        }

        target = false;
      }
    }

    function onClick(ev) {
      if (prevent) {
        ev.preventDefault();
      } // If handler was not called on touchend, call it on click;


      handler.call(this, ev, that);
    }

    function onCancel() {
      target = false;
    }

    $elm.each(function (i, elm) {
      if (that.settings.tap) {
        listen(elm, 'touchstart', onStart, {
          passive: true
        });
        listen(elm, 'touchcancel', onCancel);
        listen(elm, 'touchmove', onMove, {
          passive: true
        });
        listen(elm, 'touchend', onEnd);
      }

      listen(elm, 'click', onClick);

      elm.__mbscOff = function () {
        unlisten(elm, 'touchstart', onStart, {
          passive: true
        });
        unlisten(elm, 'touchcancel', onCancel);
        unlisten(elm, 'touchmove', onMove, {
          passive: true
        });
        unlisten(elm, 'touchend', onEnd);
        unlisten(elm, 'click', onClick);
        delete elm.__mbscOff;
      };
    });
  }

  function tapOff($elm) {
    if ($elm && $elm[0] && $elm[0].__mbscOff) {
      $elm[0].__mbscOff();
    }
  } // Prevent standard behaviour on body click


  function bustClick(ev) {
    // Textarea needs the mousedown event
    if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
      ev.stopPropagation();
      ev.preventDefault();
      return false;
    }
  }

  if (isBrowser) {
    ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
      document.addEventListener(ev, bustClick, true);
    });

    if (os == 'android' && majorVersion < 5) {
      document.addEventListener('change', function (ev) {
        if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
          ev.stopPropagation();
          ev.preventDefault();
        }

        delete ev.target.mbscChange;
      }, true);
    }
  }

  /*!
   * Mobiscroll v4.10.9
   * http://mobiscroll.com
   *
   *
   * Copyright 2010-2018, Acid Media
   *
   */

  function getWidth(el) {
    return el[0].innerWidth || el.innerWidth();
  }

  function getThemeName(s) {
    var themeName = s.theme,
        themeVariant = s.themeVariant;

    if (themeName == 'auto' || !themeName) {
      themeName = ms.autoTheme;
    }

    if (themeName == 'default') {
      themeName = 'mobiscroll';
    }

    if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {
      themeName = themeName + '-dark';
    } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {
      themeName = themeName.replace(/-dark$/, '');
    }

    return themeName;
  }

  function autoInit(selector, Component, hasRefresh) {
    if (isBrowser) {
      $$1(function () {
        $$1(selector).each(function () {
          new Component(this, {});
        });
        $$1(document).on('mbsc-enhance', function (ev, settings) {
          if ($$1(ev.target).is(selector)) {
            new Component(ev.target, settings || {});
          } else {
            $$1(selector, ev.target).each(function () {
              new Component(this, settings || {});
            });
          }
        });

        if (hasRefresh) {
          $$1(document).on('mbsc-refresh', function (ev) {
            var inst;

            if ($$1(ev.target).is(selector)) {
              inst = instances[ev.target.id];

              if (inst) {
                inst.refresh();
              }
            } else {
              $$1(selector, ev.target).each(function () {
                inst = instances[this.id];

                if (inst) {
                  inst.refresh();
                }
              });
            }
          });
        }
      });
    }
  }

  var ms,
      $$1 = mobiscroll.$,
      id = +new Date(),
      instances = {},
      classes = {},
      empty = {},
      breakpoints = {
    xsmall: 0,
    small: 576,
    medium: 768,
    large: 992,
    xlarge: 1200
  },
      extend$1 = $$1.extend;
  extend$1(util, {
    getCoord: getCoord,
    preventClick: preventClick,
    vibrate: vibrate
  });
  ms = extend$1(mobiscroll, {
    $: $$1,
    version: '4.10.9',
    autoTheme: 'mobiscroll',
    themes: {
      form: {},
      page: {},
      frame: {},
      scroller: {},
      listview: {},
      navigation: {},
      progress: {},
      card: {}
    },
    platform: {
      name: os,
      majorVersion: majorVersion,
      minorVersion: minorVersion
    },
    i18n: {},
    instances: instances,
    classes: classes,
    util: util,
    settings: {},
    setDefaults: function setDefaults(o) {
      extend$1(this.settings, o);
    },
    customTheme: function customTheme(name, baseTheme) {
      var i,
          themes = mobiscroll.themes,
          comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

      for (i = 0; i < comps.length; i++) {
        themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
          baseTheme: baseTheme
        });
      }
    }
  });

  var Base = function Base(el, settings) {
    var ctx,
        lang,
        preset,
        resp,
        s,
        theme,
        themeName,
        trigger,
        defaults,
        that = this;
    that.settings = {};
    that.element = el;
    that._init = noop;
    that._destroy = noop;
    that._processSettings = noop;

    that._checkResp = function (width) {
      if (that && that._responsive) {
        var newResp = getResponsiveSettings(width);

        if (resp !== newResp) {
          resp = newResp;
          that.init({});
          return true;
        }
      }
    };

    that._getRespCont = function () {
      return $$1(s.context == 'body' ? window : s.context);
    };

    that.init = function (newSettings, newValue) {
      var key, value; // In case of settings update save the old value

      if (newSettings && that.getVal) {
        value = that.getVal();
      } // Reset settings object


      for (key in that.settings) {
        delete that.settings[key];
      }

      s = that.settings; // Update original user settings

      extend$1(settings, newSettings); // Load user defaults

      if (that._hasDef) {
        defaults = ms.settings;
      } // Create settings object


      extend$1(s, that._defaults, defaults, settings);
      ctx = that._getRespCont();

      if (that._responsive) {
        if (!resp) {
          resp = getResponsiveSettings();
        }

        extend$1(s, resp);
      } // Get theme defaults


      if (that._hasTheme) {
        themeName = getThemeName(s);
        settings.theme = themeName;
        theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
      } // Get language defaults


      if (that._hasLang) {
        lang = ms.i18n[s.lang];
      } // Update settings object


      extend$1(s, theme, lang, defaults, settings, resp);

      that._processSettings(resp || {}); // Load preset settings


      if (that._presets) {
        preset = that._presets[s.preset];

        if (preset) {
          preset = preset.call(el, that, settings, resp);
          extend$1(s, preset, settings, resp);
        }
      }

      that._init(newSettings); // In case of settings update reset the value.
      // This is needed to adapt the value for the updated settings
      // E.g. min/max, date format, etc.


      if (newSettings && that.setVal) {
        that.setVal(newValue === undefined ? value : newValue, true);
      }

      trigger('onInit');
    };

    that.destroy = function () {
      if (that) {
        that._destroy();

        trigger('onDestroy'); // Delete scroller instance

        delete instances[el.id];
        that = null;
      }
    };
    /**
     * Attach tap event to the given element.
     */


    that.tap = function (el, handler, prevent, tolerance, time) {
      tap(that, el, handler, prevent, tolerance, time);
    };
    /**
     * Triggers an event
     */


    that.trigger = function (name, ev) {
      var ret,
          i,
          v,
          s = [defaults, theme, preset, settings];

      for (i = 0; i < 4; i++) {
        v = s[i];

        if (v && v[name]) {
          ret = v[name].call(el, ev || {}, that);
        }
      }

      return ret;
    };
    /**
     * Sets one ore more options.
     */


    that.option = function (opt, value, newValue) {
      var obj = {},
          // preserve settings that are possible to change runtime
      dynamic = ['data', 'invalid', 'valid', 'readonly'];

      if (/calendar|eventcalendar|range/.test(s.preset)) {
        dynamic.push('marked', 'labels', 'colors');
      }

      if (typeof opt === 'object') {
        obj = opt;
      } else {
        obj[opt] = value;
      }

      dynamic.forEach(function (v) {
        settings[v] = s[v];
      });
      that.init(obj, newValue);
    };
    /**
     * Returns the mobiscroll instance.
     */


    that.getInst = function () {
      return that;
    };

    settings = settings || {};
    trigger = that.trigger;

    function getResponsiveSettings(w) {
      var result = empty,
          width;

      if (s.responsive) {
        width = w || getWidth(ctx);
        $$1.each(s.responsive, function (key, value) {
          if (width >= (value.breakpoint || breakpoints[key])) {
            result = value;
          }
        });
      }

      return result;
    }

    function construct() {
      $$1(el).addClass('mbsc-comp'); // Autogenerate id

      if (!el.id) {
        el.id = 'mobiscroll' + ++id;
      } else if (instances[el.id]) {
        instances[el.id].destroy();
      } // Save instance


      instances[el.id] = that;
      that.__ready = true;
    }

    if (!that.__ready) {
      construct();
    }
  };

  var boolType = PropTypes.bool,
      stringType = PropTypes.string,
      funcType = PropTypes.func,
      numType = PropTypes.number,
      objType = PropTypes.object,
      dateType = PropTypes.oneOfType([objType, stringType]),
      numOrArray = PropTypes.oneOfType([numType, PropTypes.arrayOf(numType)]);
  /** Mixin for enumerating the core PropTypes */

  var CorePropTypes = {
    theme: stringType,
    themeVariant: PropTypes.oneOf(['auto', 'dark', 'light']),
    lang: stringType,
    rtl: boolType,
    responsive: objType,
    context: PropTypes.oneOfType([stringType, objType])
  };
  var FramePropTypes = {
    anchor: PropTypes.oneOfType([stringType, objType]),
    animate: PropTypes.oneOfType([boolType, PropTypes.oneOf(['fade', 'flip', 'pop', 'swing', 'slidevertical', 'slidehorizontal', 'slidedown', 'slideup'])]),
    buttons: PropTypes.array,
    closeOnOverlayTap: boolType,
    cssClass: stringType,
    disabled: boolType,
    display: PropTypes.oneOf(['top', 'bottom', 'bubble', 'inline', 'center']),
    focusOnClose: PropTypes.oneOfType([boolType, stringType, objType]),
    focusTrap: boolType,
    headerText: PropTypes.oneOfType([boolType, stringType, funcType]),
    layout: PropTypes.oneOf(['liquid', 'fixed']),
    scrollLock: boolType,
    showOnFocus: boolType,
    showOnTap: boolType,
    showOnOverlay: boolType,
    touchUi: boolType,
    onBeforeClose: funcType,
    onBeforeShow: funcType,
    onCancel: funcType,
    onClose: funcType,
    onDestroy: funcType,
    onMarkupReady: funcType,
    onPosition: funcType,
    onShow: funcType
  };
  var ScrollerPropTypes = {
    circular: PropTypes.oneOfType([boolType, PropTypes.arrayOf(boolType)]),
    height: numType,
    maxWidth: numOrArray,
    minWidth: numOrArray,
    multiline: numType,
    readonly: PropTypes.oneOfType([boolType, PropTypes.arrayOf(boolType)]),
    rows: numType,
    showLabel: boolType,
    showScrollArrows: boolType,
    wheels: PropTypes.array,
    width: numType,
    onChange: funcType,
    validate: funcType,
    onSet: funcType,
    onItemTap: funcType,
    onClear: funcType,
    cancelText: stringType,
    clearText: stringType,
    selectedText: stringType,
    setText: stringType,
    formatValue: funcType,
    parseValue: funcType
  };
  var DatetimePropTypes = {
    defaultValue: dateType,
    invalid: PropTypes.array,
    max: dateType,
    min: dateType,
    returnFormat: PropTypes.oneOf(['iso8601', 'moment', 'locale', 'jsdate']),
    steps: PropTypes.shape({
      hour: numType,
      minute: numType,
      second: numType,
      zeroBased: boolType
    }),
    valid: PropTypes.array,
    calendarSystem: PropTypes.oneOf(['jalali', 'hijri', 'gregorian']),
    ampmText: stringType,
    amText: stringType,
    dateFormat: stringType,
    dateWheels: stringType,
    dayNames: PropTypes.arrayOf(stringType),
    dayNamesShort: PropTypes.arrayOf(stringType),
    dayText: stringType,
    hourText: stringType,
    minuteText: stringType,
    monthNames: PropTypes.arrayOf(stringType),
    monthNamesShort: PropTypes.arrayOf(stringType),
    monthSuffix: stringType,
    monthText: stringType,
    nowText: stringType,
    pmText: stringType,
    secText: stringType,
    timeFormat: stringType,
    timeWheels: stringType,
    yearSuffix: stringType,
    yearText: stringType
  };
  var CalbasePropTypes = {
    calendarHeight: numType,
    calendarScroll: PropTypes.oneOf(['horizontal', 'vertical']),
    calendarWidth: numType,
    counter: boolType,
    defaultValue: PropTypes.oneOfType([dateType, PropTypes.array]),
    events: PropTypes.arrayOf(PropTypes.shape({
      start: dateType,
      end: dateType,
      d: PropTypes.oneOfType([objType, numType, stringType]),
      text: stringType,
      color: stringType,
      background: stringType,
      cssClass: stringType
    })),
    eventOrder: funcType,
    labels: PropTypes.arrayOf(PropTypes.shape({
      start: dateType,
      end: dateType,
      d: PropTypes.oneOfType([objType, numType, stringType]),
      text: stringType,
      color: stringType,
      background: stringType,
      cssClass: stringType
    })),
    marked: PropTypes.arrayOf(PropTypes.oneOfType([objType, numType, stringType, PropTypes.shape({
      d: PropTypes.oneOfType([objType, stringType, numType]),
      color: stringType,
      background: stringType,
      cssClass: stringType
    })])),
    colors: PropTypes.arrayOf(PropTypes.shape({
      d: PropTypes.oneOfType([objType, stringType, numType]),
      background: stringType,
      cssClass: stringType
    })),
    months: numType,
    mousewheel: boolType,
    weeks: numType,
    outerMonthChange: boolType,
    showOuterDays: boolType,
    tabs: boolType,
    weekCounter: PropTypes.oneOf(['year', 'month']),
    weekDays: PropTypes.oneOf(['full', 'short', 'min']),
    yearChange: boolType,
    dateText: stringType,
    dayNames: PropTypes.arrayOf(stringType),
    dayNamesMin: PropTypes.arrayOf(stringType),
    firstDay: numType,
    timeText: stringType,
    moreEventsPluralText: stringType,
    moreEventsText: stringType,
    onTabChange: funcType,
    onCellHoverIn: funcType,
    onCellHoverOut: funcType,
    onDayChange: funcType,
    onLabelTap: funcType,
    onMonthChange: funcType,
    onMonthLoading: funcType,
    onMonthLoaded: funcType,
    onPageChange: funcType,
    onPageLoading: funcType,
    onPageLoaded: funcType,
    onSetDate: funcType
  };
  function updateCssClasses(currentClasses, nextClasses) {
    var node = ReactDOM.findDOMNode(this);
    var currentNormal = currentClasses.replace(/\s+/g, ' ').trim();
    var nextNormal = nextClasses.replace(/\s+/g, ' ').trim();

    if (currentNormal) {
      node.classList.remove.apply(node.classList, currentNormal.split(' '));
    }

    if (nextNormal) {
      node.classList.add.apply(node.classList, nextNormal.split(' '));
    }
  }
  function deepCompare(a, b) {
    var leftChain = [],
        rightChain = [];

    function compare2Objects(x, y, reactElement) {
      var p; // remember that NaN === NaN returns false
      // and isNaN(undefined) returns true

      if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
        return true;
      } // Compare primitives and functions.     
      // Check if both arguments link to the same object.
      // Especially useful on step when comparing prototypes


      if (x === y) {
        return true;
      } else if (typeof x === 'function' && typeof y === 'function') {
        return false;
      } // Works in case when functions are created in constructor.
      // Comparing dates is a common scenario. Another built-ins?
      // We can even handle functions passed across iframes


      if (x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || x instanceof String && y instanceof String || x instanceof Number && y instanceof Number) {
        return x.toString() === y.toString();
      } // At last checking prototypes as good a we can


      if (!(x instanceof Object && y instanceof Object)) {
        return false;
      } // eslint-disable-next-line no-prototype-builtins


      if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
        return false;
      }

      if (x.constructor !== y.constructor) {
        return false;
      }

      if (x.prototype !== y.prototype) {
        return false;
      } // Check for infinitive linking loops


      if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
        return false;
      } // Quick checking of one object beeing a subset of another.
      // todo: cache the structure of arguments[0] for performance


      for (p in y) {
        // eslint-disable-next-line no-prototype-builtins
        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
          return false;
        } else if (typeof y[p] !== typeof x[p]) {
          return false;
        }
      }

      var elementProps = {
        '$$typeof': 1,
        'key': 1,
        'props': 1,
        'ref': 1,
        'type': 1
      };
      var props = reactElement ? elementProps : x;

      for (p in props) {
        // eslint-disable-next-line no-prototype-builtins
        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
          return false;
        } else if (typeof y[p] !== typeof x[p]) {
          return false;
        }

        switch (typeof x[p]) {
          case 'object':
          case 'function':
            leftChain.push(x);
            rightChain.push(y);

            if (!compare2Objects(x[p], y[p], x[p] && x[p].$$typeof !== undefined)) {
              return false;
            }

            leftChain.pop();
            rightChain.pop();
            break;

          default:
            if (x[p] !== y[p]) {
              return false;
            }

            break;
        }
      }

      return true;
    }

    return compare2Objects(a, b);
  }
  var MbscInit =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(MbscInit, _React$Component);

    function MbscInit(props) {
      var _this;

      _this = _React$Component.call(this, props) || this; // the initial css class will not change this way, and wont trigger any re-render. We will handle the className changes in the componentWillReceive function
      // Note: every render function should use the this.initialCssClass instead of passing through the className prop 

      _this.initialCssClass = _this.props.className || '';
      return _this;
    } // Dummy render function


    var _proto = MbscInit.prototype;

    _proto.render = function render() {
      return null;
    } // generates the mobiscroll options object based on the props passed
    ;

    _proto.getSettingsFromProps = function getSettingsFromProps(props, extra) {
      var optionObj = {};

      if (props !== undefined) {
        // support individual properties and options object property for settings
        // the value should not be part of the options object
        // data should not be part of the options object 

        /* eslint-disable no-unused-vars */
        // justification: the variables 'value', 'data', 'children' and 'className' are declared due to object decomposition
        var options = props.options,
            children = props.children,
            value = props.value,
            checked = props.checked,
            data = props.data,
            className = props.className,
            other = _objectWithoutPropertiesLoose(props, ["options", "children", "value", "checked", "data", "className"]);
        /* eslint-enable no-unused-vars */


        var optionStr = options || '{}';
        optionObj = options || {};

        if (options !== undefined && typeof optionStr === 'string') {
          // when options are passed as string we need to create an object from it
          optionObj = new Function('return ' + optionStr + ';')();
        } // the priority of the options passed (later will have higher prio): 
        // 1. options property
        // 2. individual properties


        optionObj = extend$1({}, optionObj, other, extra || {});
      }

      return optionObj;
    } // cleans up on unmount
    ;

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.instance.destroy(); // Also need to delete reference to the instance

      delete this.instance;
    };

    return MbscInit;
  }(React.Component);
  /** The base class for the mobiscroll components
   * Generates the Mobiscroll options object from the react component properties
   * Setting initial state 
   * Updating state based on new props 
   * Updating mobiscroll based on state */

  var MbscBase =
  /*#__PURE__*/
  function (_MbscInit) {
    _inheritsLoose(MbscBase, _MbscInit);

    function MbscBase(props) {
      var _this2;

      _this2 = _MbscInit.call(this, props) || this;
      _this2.updateForIonInput = _this2.updateForIonInput.bind(_assertThisInitialized(_this2));
      return _this2;
    }

    var _proto2 = MbscBase.prototype;

    _proto2.updateForIonInput = function updateForIonInput() {
      if (this.valueState) {
        this.optimizeUpdate = null;
        this.forceUpdate();
      }
    };

    _proto2.isIonInput = function isIonInput(children) {
      return children && React.Children.count(children) == 1 && children.type && children.type.render && children.type.render.displayName === 'IonInput';
    } // updates mobiscroll with new options
    ;

    _proto2.componentDidUpdate = function componentDidUpdate() {
      var settings = this.getSettingsFromProps(this.props);

      if (this.optimizeUpdate) {
        if (this.optimizeUpdate.updateOptions) {
          this.instance.option(settings);
        }

        if (this.optimizeUpdate.updateValue && this.props.value !== undefined && !deepCompare(this.props.value, this.instance.getVal())) {
          this.instance.setVal(this.props.value, true);
        }

        this.updateForIonInput();
      } else if (this.optimizeUpdate !== null) {
        this.instance.option(settings);

        if (this.props.value !== undefined) {
          this.instance.setVal(this.props.value, true);
        }
      }
    };

    return MbscBase;
  }(MbscInit);
  var MbscOptimized =
  /*#__PURE__*/
  function (_MbscBase) {
    _inheritsLoose(MbscOptimized, _MbscBase);

    function MbscOptimized(props) {
      return _MbscBase.call(this, props) || this;
    }

    var _proto3 = MbscOptimized.prototype;

    _proto3.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var nextOptions = this.getSettingsFromProps(nextProps);
      var thisOptions = this.getSettingsFromProps(this.props); // check if the options or the value changed

      var updateOptions = !deepCompare(nextOptions, thisOptions),
          updateValue = !deepCompare(nextProps.value, this.props.value),
          updateChildren = !deepCompare(nextProps.children, this.props.children); // save what should be updated inside mobiscroll

      this.optimizeUpdate = {
        updateOptions: updateOptions,
        updateValue: updateValue,
        updateChildren: updateChildren
      }; // component should update if the options or the value changed

      var shouldUpdate = updateOptions || updateValue || updateChildren;
      return shouldUpdate;
    };

    return MbscOptimized;
  }(MbscBase);
  /** Class for the generic mobiscroll components */

  var MbscInputBase =
  /*#__PURE__*/
  function (_MbscOptimized) {
    _inheritsLoose(MbscInputBase, _MbscOptimized);

    function MbscInputBase() {
      var _this3;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this3 = _MbscOptimized.call.apply(_MbscOptimized, [this].concat(args)) || this;

      _defineProperty(_assertThisInitialized(_this3), "element", null);

      _defineProperty(_assertThisInitialized(_this3), "inputCheckCount", 0);

      _defineProperty(_assertThisInitialized(_this3), "startInit", function () {
        // checking whether a native input element is available as a child element
        _this3.element = ReactDOM.findDOMNode(_assertThisInitialized(_this3));
        var input = $$1(_this3.element).find('input');

        if (input.length) {
          _this3.element = input[0];
        }

        _this3.inputCheckCount++; // postponing initialization required only for IonInputs in some cases. Read description above.

        var ionInput = _this3.isIonInput(_this3.props.children);

        if (!ionInput || input.length || _this3.inputCheckCount > 17) {
          _this3.initInstance(); // initialize the Mobiscroll component

        } else {
          setTimeout(_this3.startInit, 30);
        }
      });

      _defineProperty(_assertThisInitialized(_this3), "initInstance", function () {
        var settings = _this3.getSettingsFromProps(_this3.props, _this3.mbscInit);

        _this3.instance = new classes[_this3.mbscInit.component || 'Scroller'](_this3.element, settings);

        if (_this3.props.value !== undefined) {
          _this3.instance.setVal(_this3.props.value, true);

          _this3.updateForIonInput();
        }
      });

      return _this3;
    }

    var _proto4 = MbscInputBase.prototype;

    _proto4.render = function render() {
      // passing through some of the element properties to its children
      var _this$props = this.props,
          type = _this$props.type,
          readOnly = _this$props.readOnly,
          disabled = _this$props.disabled,
          placeholder = _this$props.placeholder,
          children = _this$props.children; // default input type if there are no children components

      type = type || "text";

      if (this.isIonInput(children)) {
        this.valueState = true;
        var val = this.instance ? this.instance._value : '';
        return React.cloneElement(children, _extends({
          value: val
        }, children.props));
      } // default to input if there are no childrens


      if (children) {
        return this.props.children;
      } else {
        return React.createElement("input", {
          className: this.initialCssClass,
          type: type,
          readOnly: readOnly,
          disabled: disabled,
          placeholder: placeholder
        });
      }
    };

    _proto4.componentDidMount = function componentDidMount() {
      this.startInit();
    };

    return MbscInputBase;
  }(MbscOptimized);
  /** Class for the list based mobiscroll components */

  _defineProperty(MbscInputBase, "propTypes", _extends({}, CorePropTypes, {}, FramePropTypes, {
    type: PropTypes.string,
    placeholder: PropTypes.string
  }));

  var MbscListsBase =
  /*#__PURE__*/
  function (_MbscOptimized2) {
    _inheritsLoose(MbscListsBase, _MbscOptimized2);

    function MbscListsBase() {
      return _MbscOptimized2.apply(this, arguments) || this;
    }

    var _proto5 = MbscListsBase.prototype;

    _proto5.render = function render() {
      return React.createElement("ul", {
        className: this.initialCssClass + ' mbsc-cloak'
      }, this.props.children);
    };

    _proto5.componentDidMount = function componentDidMount() {
      // get settings from state
      var settings = this.getSettingsFromProps(this.props, this.mbscInit); // get the DOM node

      var DOMNode = ReactDOM.findDOMNode(this); // initialize the mobiscroll

      this.instance = new classes[this.mbscInit.component || 'Scroller'](DOMNode, settings);

      if (this.props.value !== undefined) {
        this.instance.setVal(this.props.value, true);
      } // Stop Propagation of click events to avoid the same data-reactid js error when inline mode
      // the _markup does not exist for components that are not derived from Mobiscroll Frame (listview, menustrip, forms)
      // we can use the original dom node for these non-frame components, because they dont clone the markup


      (this.instance._markup || $$1(DOMNode)).on('click', function (event) {
        event.stopPropagation();
      });
    };

    _proto5.componentDidUpdate = function componentDidUpdate() {
      if (!this.optimizeUpdate.updateOptions && this.optimizeUpdate.updateChildren) {
        this.instance.option(this.getSettingsFromProps(this.props)); // the option needs to be called because of the children changes - the list components might need a refresh method
      } // Stop Propagation of click events to avoid the same data-reactid js error when inline mode
      // the _markup does not exist for components that are not derived from Mobiscroll Frame (listview, menustrip, forms)
      // we can use the original dom node for these non-frame components, because they dont clone the markup


      var DOMNode = ReactDOM.findDOMNode(this);
      (this.instance._markup || $$1(DOMNode)).on('click', function (event) {
        event.stopPropagation();
      });
    };

    return MbscListsBase;
  }(MbscOptimized);

  _defineProperty(MbscListsBase, "propTypes", _extends({}, CorePropTypes, {}, FramePropTypes, {}, ScrollerPropTypes));

  var wrapClass = 'mbsc-input-wrap';
  var events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
  var defaults = {
    tap: hasGhostClick
  };
  var $active;

  function addIcon($control, ic) {
    var icons = {},
        control = $control[0],
        $parent = $control.parent(),
        errorMsg = $parent.find('.mbsc-err-msg'),
        align = $control.attr('data-icon-align') || 'left',
        icon = $control.attr('data-icon');

    if ($parent.hasClass(wrapClass)) {
      $parent = $parent.parent();
    } else {
      // Wrap input
      $$1('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
    }

    if (errorMsg) {
      $parent.find('.' + wrapClass).append(errorMsg);
    }

    if (icon) {
      if (icon.indexOf('{') !== -1) {
        icons = JSON.parse(icon);
      } else {
        icons[align] = icon;
      }
    }

    if (control.type == 'file') {
      // Set icon
      icons.right = $control.attr('data-icon-upload') || 'upload';
    }

    if (icon || ic) {
      extend$1(icons, ic);
      $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
    }
  }

  function addIconToggle(that, $parent, $control) {
    var icons = {},
        control = $control[0],
        toggle = $control.attr('data-password-toggle'),
        iconShow = $control.attr('data-icon-show') || 'eye',
        iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

    if (toggle) {
      icons.right = control.type == 'password' ? iconShow : iconHide;
    }

    addIcon($control, icons);

    if (toggle) {
      tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
        if (control.type == "text") {
          control.type = "password";
          $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
        } else {
          control.type = "text";
          $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
        }
      });
    }
  }

  function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
    // Wrap non-empty text nodes in span with mbsc-label class
    if (type == 'segmented') {
      $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
    } else if (type != 'button' && type != 'submit') {
      $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
        $$1(v).attr('title', $$1(v).text());
      });
      $parent.contents().filter(function () {
        return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
      }).each(function () {
        $$1('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
      });
    }
  }

  function getRipple(theme) {
    var ripple = mobiscroll.themes.form[theme];
    return ripple && ripple.addRipple ? ripple : null;
  }

  function getAttr($elm, attr, def) {
    var v = $elm.attr(attr);
    return v === undefined || v === '' ? def : v;
  }

  function getCssClass(s) {
    var theme = getThemeName(s);
    var baseTheme = mobiscroll.themes.form[theme].baseTheme;
    return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
  }

  var FormControl =
  /*#__PURE__*/
  function () {
    function FormControl(elm, settings) {
      var _this = this;

      var s = extend$1({}, defaults, mobiscroll.settings, settings);
      var $elm = $$1(elm);
      var $p = $elm.parent();
      var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components

      var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
      var type = getControlType($elm);
      var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
      var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

      if (elm.mbscInst) {
        elm.mbscInst.destroy();
      }

      if ($frame) {
        $frame.insertAfter($parent);
      }

      s.theme = getThemeName(s);

      if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {
        s.rtl = mobiscroll.i18n[s.lang].rtl;
      }

      wrapLabel($parent, type, inputStyle, labelStyle, elm);
      $elm.addClass('mbsc-control'); // Attach events

      this._handle = this._handle.bind(this); // Prevent 300ms click latency

      events.forEach(function (ev) {
        $elm.on(ev, _this._handle);
      }); // Touch events are added separately, needs to be passive listener

      listen(elm, 'touchstart', this._handle, {
        passive: true
      });
      listen(elm, 'touchmove', this._handle, {
        passive: true
      });
      this.settings = s;
      this._type = type;
      this._elm = elm;
      this._$elm = $elm;
      this._$parent = $parent;
      this._$frame = $frame;
      this._ripple = getRipple(s.theme);
      this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');
      this.cssClass = getCssClass(s);
      this.getClassElm().addClass(this.cssClass);
      elm.mbscInst = this;
    }

    var _proto = FormControl.prototype;

    _proto.getClassElm = function getClassElm() {
      return this._$parent;
    };

    _proto.destroy = function destroy() {
      var _this2 = this;

      var $elm = this._$elm;
      var elm = this._elm;
      $elm.removeClass('mbsc-control');
      this.getClassElm().removeClass(this.cssClass);
      events.forEach(function (ev) {
        $elm.off(ev, _this2._handle);
      });
      unlisten(elm, 'touchstart', this._handle, {
        passive: true
      });
      unlisten(elm, 'touchmove', this._handle, {
        passive: true
      });
      delete elm.mbscInst;
    };

    _proto.option = function option(s) {
      extend$1(this.settings, s);
      var classElm = this.getClassElm();

      if (this.cssClass) {
        classElm.removeClass(this.cssClass);
      }

      this.cssClass = getCssClass(this.settings);
      classElm.addClass(this.cssClass);
      this._ripple = getRipple(this.settings.theme);
    };

    _proto._handle = function _handle(ev) {
      switch (ev.type) {
        case 'touchstart':
        case 'mousedown':
          this._onStart(ev);

          break;

        case 'touchmove':
        case 'mousemove':
          this._onMove(ev);

          break;

        case 'touchend':
        case 'touchcancel':
        case 'mouseup':
        case 'mouseleave':
          this._onEnd(ev);

          break;
      }
    };

    _proto._addRipple = function _addRipple(ev) {
      if (this._ripple && this._$rippleElm) {
        this._ripple.addRipple(this._$rippleElm, ev);
      }
    };

    _proto._removeRipple = function _removeRipple() {
      if (this._ripple && this._$rippleElm) {
        this._ripple.removeRipple();
      }
    };

    _proto._onStart = function _onStart(ev) {
      var elm = this._elm;

      if (testTouch(ev, elm)) {
        this._startX = getCoord(ev, 'X');
        this._startY = getCoord(ev, 'Y');

        if ($active) {
          $active.removeClass('mbsc-active');
        }

        if (!elm.disabled) {
          this._isActive = true;
          $active = this._$elm;
          $active.addClass('mbsc-active');

          this._addRipple(ev);
        }
      }

      if (ev.type == 'touchstart') {
        this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }
    };

    _proto._onMove = function _onMove(ev) {
      // If movement is more than 9px, don't fire the click event handler
      if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
        this._$elm.removeClass('mbsc-active');

        this._removeRipple();

        this._isActive = false;
      }
    };

    _proto._onEnd = function _onEnd(ev) {
      var _this3 = this;

      var control = this._elm;
      var type = this._type;

      if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
        activateControl(control, type, ev);
      }

      if (this._isActive) {
        setTimeout(function () {
          _this3._$elm.removeClass('mbsc-active');

          _this3._removeRipple();
        }, 100);
      }

      this._isActive = false;
      $active = null;
    };

    return FormControl;
  }();
  mobiscroll.themes.form.mobiscroll = {};

  var events$1 = ['focus', 'change', 'blur', 'animationstart'];
  var Input =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(Input, _FormControl);

    function Input(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;
      var $elm = _this._$elm;
      var $parent = _this._$parent;
      var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');
      addIconToggle(_assertThisInitialized(_this), $parent, $elm);
      _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));
      _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));
      _this._setText = _this._setText.bind(_assertThisInitialized(_this));

      if (elm.type == 'file') {
        // Copy attributes and create dummy input
        var $existing = $parent.find('.mbsc-file-input');
        _this._$input = $existing.length ? $existing : $$1('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm); // Copy value on file upload

        $elm.on('change', _this._setText);
      }

      $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events

      events$1.forEach(function (ev) {
        $elm.on(ev, _this._checkLabel);
      }); // Move the dummy input after the element for correct styling

      if ($dummy.length) {
        $elm.after($dummy);

        if ($dummy.hasClass('mbsc-select-input')) {
          _this._delm = $dummy[0];

          _this.refresh();
        }
      }

      return _this;
    }

    var _proto = Input.prototype;

    _proto._setText = function _setText(ev) {
      var files = ev.target.files;
      var names = [];

      for (var i = 0; i < files.length; ++i) {
        names.push(files[i].name);
      }

      this._$input.val(names);
    };

    _proto._checkLabel = function _checkLabel(ev) {
      if (this._isFloating) {
        // In case of select we need to check the dummy element
        var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire 
        // due to the empty animation added in the css,
        // because there's no other event in case of the initial autofill

        if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
          this._$parent.addClass('mbsc-label-floating-active');
        } else {
          this._$parent.removeClass('mbsc-label-floating-active');
        }
      }
    };

    _proto._mouseDown = function _mouseDown(ev) {
      // Will prevent floating label animation when loosing focus only for a brief moment
      if (document.activeElement === this._elm && ev.target !== this._elm) {
        ev.preventDefault();
      }
    };

    _proto.refresh = function refresh() {
      this._checkLabel();
    };

    _proto.destroy = function destroy() {
      var _this2 = this;

      _FormControl.prototype.destroy.call(this);

      this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

      this._$parent.find('.mbsc-input-fill').remove();

      events$1.forEach(function (ev) {
        _this2._$elm.off(ev, _this2._checkLabel);
      });

      this._$elm.off('change', this._setText);
    };

    return Input;
  }(FormControl); // Init mbsc-input elements on page load

  autoInit('[mbsc-input]', Input);

  var Button =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(Button, _FormControl);

    function Button(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;
      var $elm = _this._$elm;
      var hasIcon = $elm.attr('data-icon');
      $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();

      if (hasIcon) {
        $elm.prepend('<span class="mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '"></span>');

        if ($elm.text() === "") {
          $elm.addClass('mbsc-btn-icon-only');
        }
      }

      _this._$rippleElm = $elm;
      return _this;
    }

    var _proto = Button.prototype;

    _proto.getClassElm = function getClassElm() {
      return this._$elm;
    };

    return Button;
  }(FormControl); // Init mbsc-button elements on page load

  autoInit('[mbsc-button]', Button);

  var CheckBox =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(CheckBox, _FormControl);

    function CheckBox(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;

      _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();

      _this._$elm.after('<span class="mbsc-checkbox-box"></span>');

      return _this;
    }

    return CheckBox;
  }(FormControl); // Init mbsc-checkbox elements on page load

  autoInit('[mbsc-checkbox]', CheckBox);

  var Radio =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(Radio, _FormControl);

    function Radio(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;

      _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();

      _this._$elm.after('<span class="mbsc-radio-box"><span></span></span>');

      return _this;
    }

    return Radio;
  }(FormControl); // Init mbsc-radio elements on page load

  autoInit('[mbsc-radio]', Radio);

  var Select =
  /*#__PURE__*/
  function (_Input) {
    _inheritsLoose(Select, _Input);

    function Select(elm, settings) {
      var _this;

      _this = _Input.call(this, elm, settings) || this;
      var $elm = _this._$elm;
      var $parent = _this._$parent;
      var $existing = $parent.find('.mbsc-select-input');
      var $input = $existing.length ? $existing : $$1('<input tabindex="-1" class="mbsc-select-input mbsc-control" readonly>');
      _this._$input = $input;
      _this._delm = $input[0];
      _this._setText = _this._setText.bind(_assertThisInitialized(_this));
      $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));
      $elm.after($input);
      $input.after('<span class="mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"></span>'); // Update dummy input text on change

      $elm.on('change', _this._setText);

      _this._setText();

      return _this;
    }

    var _proto = Select.prototype;

    _proto.destroy = function destroy() {
      _Input.prototype.destroy.call(this);

      this._$parent.find('.mbsc-select-ic').remove();

      this._$elm.off('change', this._setText);
    };

    _proto._setText = function _setText() {
      var elm = this._elm;
      var $elm = $$1(elm); // Check if select and mobiscroll select was not initialized

      if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {
        this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');
      } // Check floating label


      this.refresh();
    };

    return Select;
  }(Input); // Init mbsc-select elements on page load

  autoInit('[mbsc-dropdown]', Select);

  var events$2 = ['change', 'keydown', 'input', 'scroll'];
  var sizeDebounce;

  function sizeTextAreas() {
    clearTimeout(sizeDebounce);
    sizeDebounce = setTimeout(function () {
      $$1('textarea.mbsc-control').each(function () {
        sizeTextArea(this);
      });
    }, 100);
  }

  function sizeTextArea(control) {
    var height,
        lineNr,
        line,
        rowNr = $$1(control).attr('rows') || 6;

    if (control.offsetHeight) {
      control.style.height = '';
      line = control.scrollHeight - control.offsetHeight;
      height = control.offsetHeight + (line > 0 ? line : 0);
      lineNr = Math.round(height / 24);

      if (lineNr > rowNr) {
        //control.scrollTop = height;
        height = 24 * rowNr + (height - lineNr * 24);
        $$1(control).addClass('mbsc-textarea-scroll');
      } else {
        $$1(control).removeClass('mbsc-textarea-scroll');
      }

      if (height) {
        control.style.height = height + 'px';
      }
    }
  }

  function scrollTextArea(elm) {
    var $elm = $$1(elm);

    if (!$elm.hasClass('mbsc-textarea-scroll')) {
      var line = elm.scrollHeight - elm.offsetHeight,
          height = elm.offsetHeight + line,
          lineNr = Math.round(height / 24),
          rowNr = $elm.attr('rows') || 6;

      if (lineNr <= rowNr) {
        elm.scrollTop = 0;
        elm.style.height = height + 'px';
      }
    }
  }

  if (isBrowser) {
    // Set height of textareas on viewport size changes
    $$1(window).on('resize orientationchange', sizeTextAreas);
  }

  var TextArea =
  /*#__PURE__*/
  function (_Input) {
    _inheritsLoose(TextArea, _Input);

    function TextArea(elm, settings) {
      var _this;

      _this = _Input.call(this, elm, settings) || this;

      _this._$parent.addClass('mbsc-textarea');

      events$2.forEach(function (ev) {
        _this._$elm.on(ev, _this._handle);
      });
      sizeTextArea(elm);
      return _this;
    }

    var _proto = TextArea.prototype;

    _proto.destroy = function destroy() {
      var _this2 = this;

      _Input.prototype.destroy.call(this);

      events$2.forEach(function (ev) {
        _this2._$elm.off(ev, _this2._handle);
      });
    };

    _proto.refresh = function refresh() {
      _Input.prototype.refresh.call(this);

      clearTimeout(this._debounce);
      sizeTextArea(this._elm);
    };

    _proto._handle = function _handle(ev) {
      _Input.prototype._handle.call(this, ev);

      switch (ev.type) {
        case 'change':
          sizeTextArea(this._elm);
          break;

        case 'keydown':
        case 'input':
          this._onInput(ev);

          break;

        case 'scroll':
          scrollTextArea(this._elm);
      }
    };

    _proto._onInput = function _onInput() {
      var _this3 = this;

      clearTimeout(this._debounce);
      this._debounce = setTimeout(function () {
        sizeTextArea(_this3._elm);
      }, 100);
    };

    return TextArea;
  }(Input);

  autoInit('[mbsc-textarea]', TextArea);

  var SegmentedItem =
  /*#__PURE__*/
  function (_FormControl) {
    _inheritsLoose(SegmentedItem, _FormControl);

    function SegmentedItem(elm, settings) {
      var _this;

      _this = _FormControl.call(this, elm, settings) || this;
      var $segmentCont;
      var $segment;
      var $elm = _this._$elm;
      var $parent = _this._$parent;

      if (!$parent.hasClass('mbsc-segmented-item-ready')) {
        $segmentCont = $$1('<div class="mbsc-segmented mbsc-segmented-group mbsc-no-touch"></div>');
        $parent.after($segmentCont);
        $parent.parent().find('input[name="' + $elm.attr('name') + '"]').each(function () {
          var $input = $$1(this);
          $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');
          $$1('<span class="mbsc-segmented-content">' + ($input.attr('data-icon') ? '<span class="mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);
          $segment.prepend($input);
          $segmentCont.append($segment);
        });
      }

      _this._$rippleElm = $elm.next();
      return _this;
    }

    var _proto = SegmentedItem.prototype;

    _proto.getClassElm = function getClassElm() {
      return this._$elm.closest('.mbsc-segmented');
    };

    return SegmentedItem;
  }(FormControl); // Init mbsc-segmented elements on page load

  autoInit('[mbsc-segmented]', SegmentedItem);

  function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
    var $btn,
        changed,
        index,
        running,
        source,
        startX,
        startY,
        step,
        timer,
        check = isReadOnly || noop;

    function onBtnStart(ev) {
      var proceed;
      $btn = $$1(ev.currentTarget);
      step = +$btn.attr('data-step');
      index = +$btn.attr('data-index');
      changed = true;

      if (stopProp) {
        ev.stopPropagation();
      }

      if (ev.type == 'touchstart') {
        $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }

      if (ev.type == 'mousedown') {
        // Prevent focus
        ev.preventDefault();
      }

      if (ev.type != 'keydown') {
        //e.preventDefault();
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        proceed = testTouch(ev, this);
      } else {
        proceed = ev.keyCode === 32;
      }

      if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
        if (start(index, step, ev)) {
          $btn.addClass('mbsc-active');

          if (ripple) {
            ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
          }
        }

        if (ev.type == 'mousedown') {
          $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
        }
      }
    }

    function onBtnMove(ev) {
      if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
        changed = true;
        stop();
      }
    }

    function onBtnEnd(ev) {
      if (ev.type == 'touchend') {
        // Prevents iOS scroll on double tap
        ev.preventDefault();
      }

      stop();

      if (ev.type == 'mouseup') {
        $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
      }
    }

    function stop() {
      running = false;
      clearInterval(timer);

      if ($btn) {
        $btn.removeClass('mbsc-active');

        if (ripple) {
          setTimeout(function () {
            ripple.removeRipple();
          }, 100);
        }
      }
    }

    function start(i, st, ev) {
      if (!running && !check(i)) {
        index = i;
        step = st;
        source = ev;
        running = true;
        changed = false;
        setTimeout(tick, 100);
      }

      return running;
    }

    function tick() {
      if ($btn && $btn.hasClass('mbsc-disabled')) {
        stop();
        return;
      }

      if (running || !changed) {
        changed = true;
        action(index, step, source, tick);
      }

      if (running && delay) {
        clearInterval(timer);
        timer = setInterval(function () {
          action(index, step, source);
        }, delay);
      }
    }

    function destroy() {
      $elm.each(function (i, el) {
        unlisten(el, 'touchstart', onBtnStart, {
          passive: true
        });
        unlisten(el, 'mousedown', onBtnStart);
        unlisten(el, 'keydown', onBtnStart);
        unlisten(el, 'touchmove', onBtnMove, {
          passive: true
        });
        unlisten(el, 'touchend', onBtnEnd);
        unlisten(el, 'touchcancel', onBtnEnd);
        unlisten(el, 'keyup', onBtnEnd);
      });
    }

    $elm.each(function (i, el) {
      listen(el, 'touchstart', onBtnStart, {
        passive: true
      });
      listen(el, 'mousedown', onBtnStart);
      listen(el, 'keydown', onBtnStart);
      listen(el, 'touchmove', onBtnMove, {
        passive: true
      });
      listen(el, 'touchend', onBtnEnd);
      listen(el, 'touchcancel', onBtnEnd);
      listen(el, 'keyup', onBtnEnd);
    });
    return {
      start: start,
      stop: stop,
      destroy: destroy
    };
  }

  var Stepper = function Stepper(control, settings) {
    var $btnPlus,
        $btnMinus,
        $controls,
        cssClass = '',
        displayValue,
        max,
        min,
        inputStyle,
        ripple,
        scale,
        step,
        stepper,
        s,
        theme,
        val,
        that = this,
        $control = $$1(control),
        ready,
        $parent,
        old = val;

    function onChange() {
      var v;

      if (!control.disabled) {
        v = parseFloat($$1(this).val());
        setValue(isNaN(v) ? val : v);
      }
    }

    function checkDisabled() {
      return control.disabled;
    }

    function stepValue(index, dir) {
      setValue(val + dir * step);
    }

    function setValue(v, fill, change) {
      old = val;

      if (fill === undefined) {
        fill = true;
      }

      if (change === undefined) {
        change = fill;
      }

      val = round(v);
      $controls.removeClass('mbsc-disabled');

      if (fill) {
        $control.val(val);
      }

      if (val == min) {
        $btnMinus.addClass('mbsc-disabled');
      }

      if (val == max) {
        $btnPlus.addClass('mbsc-disabled');
      }

      if (val !== old && change) {
        $control.trigger('change');
      }
    }

    function getAttr(attr, def, str) {
      var v = $control.attr(attr);
      return v === undefined || v === '' ? def : str ? v : +v;
    }

    function round(v) {
      return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);
    } // Call the parent constructor


    Base.call(this, control, settings, true);
    /* TRIALFUNC */

    that.getVal = function () {
      var v = parseFloat($control.val());
      v = isNaN(v) ? val : v;
      return round(v);
    };

    that.setVal = function (v, fill, change) {
      v = parseFloat(v);
      setValue(isNaN(v) ? val : v, fill, change);
    };

    that._init = function () {
      ready = $control.parent().hasClass('mbsc-stepper');
      $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();
      s = that.settings;
      min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
      max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
      step = settings.step === undefined ? getAttr('step', s.step) : settings.step;
      scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;
      inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
      displayValue = $control.attr('data-val') || s.val;
      val = round(+control.value || 0);
      theme = mobiscroll.themes.form[s.theme];
      ripple = theme && theme.addRipple ? theme : null;

      if (!ready) {
        $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class="mbsc-segmented mbsc-stepper' + '"></span>').find('.mbsc-stepper').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '" data-step="-1" tabindex="0"><span class="mbsc-segmented-content"><span class="mbsc-ic mbsc-ic-minus"></span></span></span>').append('<span class="mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '"  data-step="1" tabindex="0"><span class="mbsc-segmented-content"> <span class="mbsc-ic mbsc-ic-plus"></span></span></span>').prepend($control);
      }

      if (cssClass) {
        $parent.removeClass(cssClass).find('.mbsc-segmented').removeClass(cssClass);
      }

      cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
      $parent.addClass(cssClass).find('.mbsc-segmented').addClass(cssClass);
      $btnMinus = $$1('.mbsc-stepper-minus', $parent);
      $btnPlus = $$1('.mbsc-stepper-plus', $parent);
      $controls = $$1('.mbsc-stepper-control', $parent);

      if (!ready) {
        if (displayValue == 'left') {
          $parent.addClass('mbsc-stepper-val-left');
          $control.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
        } else if (displayValue == 'right') {
          $parent.addClass('mbsc-stepper-val-right');
          $btnPlus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content"></span></span>');
        } else {
          $btnMinus.after('<span class="mbsc-segmented-item"><span class="mbsc-segmented-content mbsc-stepper-val"></span></span>');
        }
      }

      if (!stepper) {
        $control.on('change', onChange);
        stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);
      }

      $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');
      control.mbscInst = that;
    };

    that._destroy = function () {
      $control.removeClass('mbsc-control').off('change', onChange);
      stepper.destroy();
      delete control.mbscInst;
    };

    that.init();
  };
  Stepper.prototype = {
    _class: 'stepper',
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _defaults: {
      min: 0,
      max: 100,
      step: 1
    }
  };
  classes.Stepper = Stepper; // Init mbsc-stepper elements on page load

  autoInit('[mbsc-stepper]', Stepper);

  var ProgressBase = function ProgressBase(elm, settings, inherit) {
    var $elm,
        $parent,
        cssClass,
        s,
        that = this; // Call the parent constructor

    Base.call(this, elm, settings, true);
    that.__init = noop;
    that.__destroy = noop;

    that._init = function () {
      var wasInit;
      s = that.settings;
      $elm = $$1(elm); // Check if the element was already initialized

      wasInit = !!$parent;
      $parent = $elm.parent();
      $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;
      that._$parent = $parent;

      if (cssClass) {
        $parent.removeClass(cssClass);
      }

      cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);
      $parent.addClass(cssClass);
      $elm.addClass('mbsc-control');

      that.__init();

      if (!wasInit) {
        that._attachChange();
      } // Show initial value


      that.refresh();
      elm.mbscInst = that;
    };

    that._destroy = function () {
      that.__destroy();

      $parent.removeClass(cssClass);
      $elm.removeClass('mbsc-control');
      delete elm.mbscInst;
    };

    if (!inherit) {
      that.init();
    }
  };

  var SliderBase = function SliderBase(elm, settings, inherit) {
    var $elm,
        $handle,
        $handleCont,
        $handles,
        $listeners,
        $parent,
        $track,
        action,
        base,
        changed,
        diffX,
        diffY,
        diff,
        endX,
        endY,
        handleIndex,
        isHover,
        isPressed,
        isRtl,
        live,
        max,
        min,
        moved,
        multiple,
        oldValue,
        step,
        s,
        scale,
        startX,
        startY,
        stepDecimal,
        timer,
        totalWidth,
        value,
        that = this,
        lastUpdate = new Date();

    function onStart(ev) {
      if (ev.type === 'mousedown') {
        ev.preventDefault();
      }

      if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly
      /* TRIALCOND */
      ) {
          if (s.stopProp) {
            ev.stopPropagation();
          }

          action = true;
          moved = false;
          changed = false;
          startX = getCoord(ev, 'X');
          startY = getCoord(ev, 'Y');
          endX = startX;
          $track.removeClass('mbsc-progress-anim');
          $handle = multiple ? $$1('.mbsc-slider-handle', this) : $handles;

          if ($handleCont) {
            $handleCont.removeClass('mbsc-handle-curr');
          }

          $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');
          $elm.addClass('mbsc-active');
          handleIndex = +$handle.attr('data-index');
          totalWidth = $track[0].offsetWidth;
          diff = $track[0].getBoundingClientRect().left;

          if (ev.type === 'mousedown') {
            isPressed = true;
            $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
          }

          if (ev.type === 'mouseenter') {
            isHover = true;
            $$1(document).on('mousemove', onMove);
          }
        }
    }

    function onMove(ev) {
      if (action) {
        endX = getCoord(ev, 'X');
        endY = getCoord(ev, 'Y');
        diffX = endX - startX;
        diffY = endY - startY;

        if (Math.abs(diffX) > 5) {
          moved = true;
        }

        if (moved || isPressed || isHover) {
          if (Math.abs(lastUpdate - new Date()) > 50) {
            lastUpdate = new Date();
            updateSlider(endX, s.round, live && (!isHover || isPressed));
          }
        }

        if (moved) {
          ev.preventDefault();
        } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {
          cleanUp();
        }
      }
    }

    function onEnd(ev) {
      if (action) {
        ev.preventDefault();

        if (!multiple) {
          $track.addClass('mbsc-progress-anim');
        }

        if (isHover && !isPressed) {
          updateValue(value[handleIndex], handleIndex, false, false, true);
        } else {
          updateSlider(endX, true, true);
        }

        if (!moved && !changed) {
          if (ev.type == 'touchend') {
            // Prevent ghost click
            preventClick();
          }

          that._onTap(value[handleIndex]);
        }

        if (ev.type == 'mouseup') {
          isPressed = false;
        }

        if (ev.type == 'mouseleave') {
          isHover = false;
        }

        if (!isHover) {
          cleanUp();
        }
      }
    }

    function onCancel() {
      if (action) {
        cleanUp();
      }
    }

    function onChange() {
      var v = that._readValue($$1(this)),
          i = +$$1(this).attr('data-index');

      if (v !== value[i]) {
        value[i] = v;
        oldValue[i] = v;
        updateValue(v, i);
      }
    }

    function onClick(ev) {
      // Prevent propagating click to label
      ev.stopPropagation();
    }

    function onLabelClick(ev) {
      // Prevent change on label click for swithes
      ev.preventDefault();
    }

    function onKeyDown(ev) {
      var dir;

      if (!elm.disabled) {
        switch (ev.keyCode) {
          case 38:
          case 39:
            dir = 1;
            break;

          case 40:
          case 37:
            dir = -1;
            break;
        }

        if (dir) {
          ev.preventDefault();

          if (!timer) {
            handleIndex = +$$1(this).attr('data-index');
            updateValue(value[handleIndex] + step * dir, handleIndex, true);
            timer = setInterval(function () {
              updateValue(value[handleIndex] + step * dir, handleIndex, true);
            }, 200);
          }
        }
      }
    }

    function onKeyUp(ev) {
      ev.preventDefault();
      clearInterval(timer);
      timer = null;
    }

    function cleanUp() {
      action = false;
      $handleCont.removeClass('mbsc-active');
      $elm.removeClass('mbsc-active'); // Detach document events

      $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
    }

    function updateSlider(pos, round, fill) {
      var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));

      if (isRtl) {
        percent = 100 - percent;
      }

      updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);
    }

    function updateValue(v, index, fill, percent, refresh, change) {
      var $handle = $handles.eq(index),
          $handleCont = $handle.parent();
      v = Math.min(max, Math.max(v, min));

      if (change === undefined) {
        change = fill;
      }

      if (that._update) {
        v = that._update(v, value, index, percent, multiple, refresh, $handleCont);
      } else {
        $handleCont.css({
          left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
          right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
        });
      }

      if (v > min) {
        $handleCont.removeClass('mbsc-slider-start');
      } else if (value[index] > min || refresh) {
        $handleCont.addClass('mbsc-slider-start');
      } // Store new value


      if (fill) {
        value[index] = v;
      } // Check if value changed


      if (fill && oldValue[index] != v) {
        changed = true;
        oldValue[index] = v; // Set new value to the input

        that._fillValue(v, index, change);
      }

      $handle.attr('aria-valuenow', v);
    } // Call the parent constructor


    ProgressBase.call(this, elm, settings, true);
    that._onTap = noop;
    that.___init = noop;
    that.___destroy = noop;

    that._attachChange = function () {
      $elm.on(s.changeEvent, onChange);
    };

    that.__init = function () {
      var wasInit;

      if ($handles) {
        wasInit = true;
        $handles.parent().remove();
      }

      that.___init();

      $parent = that._$parent;
      $track = that._$track;
      $elm = $parent.find('input');
      s = that.settings;
      min = that._min;
      max = that._max;
      base = that._base || 0;
      step = that._step;
      live = that._live;
      stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;
      scale = 100 / (max - min + base) || 100;
      multiple = $elm.length > 1;
      isRtl = s.rtl;
      value = [];
      oldValue = []; // Read values

      $elm.each(function (i) {
        value[i] = that._readValue($$1(this));
        $$1(this).attr('data-index', i);
      });
      $handles = $parent.find('.mbsc-slider-handle');
      $listeners = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont'); // Attach events

      $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);
      $listeners.each(function (i, listener) {
        listen(listener, 'touchstart', onStart, {
          passive: true
        });
        listen(listener, 'mousedown', onStart);
        listen(listener, 'touchend', onEnd);
        listen(listener, 'touchcancel', onEnd);
        listen(listener, 'pointercancel', onCancel);

        if (s.hover) {
          listen(listener, 'mouseenter', onStart);
          listen(listener, 'mouseleave', onEnd);
        }
      });

      if (!wasInit) {
        $elm.on('click', onClick);
        $parent.on('click', onLabelClick); // Attach to document to avoid non-passive listener warnings

        listen(document, 'touchmove', onMove, {
          passive: false
        });
      }
    };

    that.__destroy = function () {
      $parent.off('click', onLabelClick);
      $elm.off(s.changeEvent, onChange).off('click', onClick);
      $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);
      $listeners.each(function (i, listener) {
        unlisten(listener, 'touchstart', onStart, {
          passive: true
        });
        unlisten(listener, 'mousedown', onStart);
        unlisten(listener, 'touchend', onEnd);
        unlisten(listener, 'touchcancel', onEnd);
        unlisten(listener, 'pointercancel', onCancel);
        unlisten(listener, 'mouseenter', onStart);
        unlisten(listener, 'mouseleave', onEnd);
        unlisten(document, 'touchmove', onMove, {
          passive: false
        });
      });

      that.___destroy();
    };

    that.refresh = function () {
      $elm.each(function (i) {
        updateValue(that._readValue($$1(this)), i, true, false, true, false);
      });
    };

    that.getVal = function () {
      return multiple ? value.slice(0) : value[0];
    };

    that.setVal = that._setVal = function (val, fill, change) {
      if (!$$1.isArray(val)) {
        val = [val];
      }

      $$1.each(val, function (i, v) {
        value[i] = v;
      });
      $$1.each(val, function (i, v) {
        updateValue(v, i, true, false, true, change);
      });
    };

    if (!inherit) {
      that.init();
    }
  };

  var Switch = function Switch(elm, settings) {
    var $elm,
        $parent,
        s,
        formControl,
        that = this;
    settings = settings || {};
    extend$1(settings, {
      changeEvent: 'click',
      round: false
    }); // Call the parent constructor

    SliderBase.call(this, elm, settings, true);

    that._readValue = function () {
      return elm.checked ? 1 : 0;
    };

    that._fillValue = function (v, index, change) {
      $elm.prop('checked', !!v);

      if (change) {
        $elm.trigger('change');
      }
    };

    that._onTap = function (v) {
      that._setVal(v ? 0 : 1);
    };

    that.___init = function () {
      s = that.settings;
      $elm = $$1(elm);
      $parent = $elm.parent();
      $parent.find('.mbsc-switch-track').remove();
      $parent.prepend($elm);
      $elm.attr('data-role', 'switch').after('<span class="mbsc-progress-cont mbsc-switch-track">' + '<span class="mbsc-progress-track mbsc-progress-anim">' + '<span class="mbsc-slider-handle-cont">' + '<span class="mbsc-slider-handle mbsc-switch-handle" data-index="0">' + '<span class="mbsc-switch-txt-off">' + s.offText + '</span>' + '<span class="mbsc-switch-txt-on">' + s.onText + '</span>' + '</span></span></span></span>');

      if (formControl) {
        formControl.destroy();
      }

      formControl = new FormControl(elm, s);
      that._$track = $parent.find('.mbsc-progress-track');
      that._min = 0;
      that._max = 1;
      that._step = 1;
    };

    that.___destroy = function () {
      formControl.destroy();
    };

    that.getVal = function () {
      return elm.checked;
    };

    that.setVal = function (val, fill, change) {
      that._setVal(val ? 1 : 0, fill, change);
    };

    that.init();
  };
  Switch.prototype = {
    _class: 'switch',
    _css: 'mbsc-switch',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      stopProp: true,
      offText: 'Off',
      onText: 'On'
    }
  };
  classes.Switch = Switch; // Init mbsc-switch elements on page load

  autoInit('[mbsc-switch]', Switch);

  // eslint-disable-next-line no-unused-vars
  var Progress = function Progress(elm, settings, inherit) {
    var $display,
        $elm,
        $parent,
        $progress,
        $target,
        $track,
        min,
        max,
        inputStyle,
        labelStyle,
        s,
        template,
        value,
        valueText,
        that = this;

    function onChange() {
      var v = getAttr('value', min);

      if (v !== value) {
        updateValue(v);
      }
    }

    function getAttr(attr, def, str) {
      var v = $elm.attr(attr);
      return v === undefined || v === '' ? def : str ? v : +v;
    }

    function updateValue(v, refresh, fill, change) {
      v =
      /* TRIALCONDREV */
      Math.min(max, Math.max(v, min));
      $progress.css('width', (v - min) * 100 / (max - min) + '%');

      if (fill === undefined) {
        fill = true;
      }

      if (change === undefined) {
        change = fill;
      }

      if (v !== value || refresh) {
        // Display value
        that._display(v);
      }

      if (v !== value) {
        // Set new value
        value = v; // Put new value in the progress element

        if (fill) {
          $elm.attr('value', value);
        } // Trigger change on the element


        if (change) {
          $elm.trigger('change');
        }
      }
    } // Call the parent constructor


    ProgressBase.call(this, elm, settings, true);

    that._display = function (v) {
      valueText = template && s.returnAffix ? template.replace(/\{value\}/, v).replace(/\{max\}/, max) : v;

      if ($target) {
        $target.html(valueText);
      }

      if ($display) {
        $display.html(valueText);
      }
    };

    that._attachChange = function () {
      $elm.on('change', onChange);
    };

    that.__init = function () {
      var displayValue, i, stepLabels, wasInit;
      s = that.settings;
      $elm = $$1(elm); // Check if the element was already initialized

      wasInit = !!$parent;
      $parent = that._$parent; // Read settings from data attributes or settings object

      min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;
      max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;
      inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;
      labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;
      value = getAttr('value', min);
      displayValue = $elm.attr('data-val') || s.val;
      stepLabels = $elm.attr('data-step-labels');
      stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;
      template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);

      if (!wasInit) {
        wrapLabel($parent, null, inputStyle, labelStyle, elm);
        addIcon($elm); // Generate track and progress

        $parent.find('.mbsc-input-wrap').append('<span class="mbsc-progress-cont"><span class="mbsc-progress-track mbsc-progress-anim"><span class="mbsc-progress-bar"></span></span></span>');
        $progress = that._$progress = $parent.find('.mbsc-progress-bar');
        $track = that._$track = $parent.find('.mbsc-progress-track');
      } else {
        if (displayValue) {
          $display.remove();
          $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));
        }

        if (stepLabels) {
          $$1('.mbsc-progress-step-label', $track).remove();
        }
      } // Set attributes


      $elm.attr('min', min).attr('max', max); // Generate value container on left or right side

      if (displayValue) {
        $display = $$1('<span class="mbsc-progress-value"></span>');
        $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);
      } // Generate step labels


      if (stepLabels) {
        for (i = 0; i < stepLabels.length; ++i) {
          $track.append('<span class="mbsc-progress-step-label" style="' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%" >' + stepLabels[i] + '</span>');
        }
      }

      $target = $$1($elm.attr('data-target') || s.target);
    };

    that.__destroy = function () {
      $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();
      $parent.find('.mbsc-input-ic').remove();
      $elm.off('change', onChange);
    };

    that.refresh = function () {
      updateValue(getAttr('value', min), true, false);
    };

    that.getVal = function () {
      return value;
    };

    that.setVal = function (v, fill, change) {
      updateValue(v, true, fill, change);
    };

    if (!inherit) {
      that.init();
    }
  };
  Progress.prototype = {
    _class: 'progress',
    _css: 'mbsc-progress',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      min: 0,
      max: 100,
      returnAffix: true
    }
  };
  classes.Progress = Progress; // Init mbsc-progress elements on page load

  autoInit('[mbsc-progress]', Progress);

  var Slider = function Slider(elm, settings, inherit) {
    var $elm,
        $parent,
        $progress,
        $tooltips,
        $track,
        hasProgress,
        hasTooltip,
        isRange,
        isRtl,
        max,
        min,
        step,
        s,
        that = this; // Call the parent constructor

    Progress.call(this, elm, settings, true);
    var progressInit = that.__init,
        progressDestroy = that.__destroy;
    SliderBase.call(this, elm, settings, true);
    var sliderInit = that.__init,
        sliderDestroy = that.__destroy; // ---

    that.__init = function () {
      progressInit();
      sliderInit();
    };

    that.__destroy = function () {
      progressDestroy();
      sliderDestroy();
    };

    that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {
      if (isRange) {
        if (index === 0) {
          v = Math.min(v, value[1]);
          $progress.css({
            width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',
            left: isRtl ? 'auto' : getPercent(v, min, max) + '%',
            right: isRtl ? getPercent(v, min, max) + '%' : 'auto'
          });
        } else {
          v = Math.max(v, value[0]);
          $progress.css({
            width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'
          });
        }
      } else if (multiple || !hasProgress) {
        $handleCont.css({
          left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',
          right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'
        });
      } else {
        $progress.css('width', (percent || getPercent(v, min, max)) + '%');
      }

      if (hasTooltip) {
        $tooltips.eq(index).html(v);
      } // Display value in the specified container(s)


      if (!multiple && (value[index] != v || refresh)) {
        that._display(v);
      } // Return validated value


      return v;
    };

    that._readValue = function ($elm) {
      return +$elm.val();
    };

    that._fillValue = function (v, index, change) {
      $elm.eq(index).val(v);

      if (change) {
        $elm.eq(index).trigger('change');
      }
    };

    that._markupReady = function () {
      var i, stepNr;

      if (hasTooltip) {
        $parent.addClass('mbsc-slider-has-tooltip');
      } // Generate step marks


      if (step != 1) {
        stepNr = (max - min) / step;

        for (i = 0; i <= stepNr; ++i) {
          $track.append('<span class="mbsc-slider-step" style="' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%"></span>');
        }
      } // Generate slider handles


      $elm.each(function (i, elm) {
        var value = +elm.value;

        if (elm.type == 'range') {
          // Set min / max / step properties for all inputs
          $$1(elm).attr('min', min).attr('max', max).attr('step', step);
        }

        (hasProgress ? $progress : $track).append('<span class="mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + (isRange && !i && value > (max - min) / 2 ? ' mbsc-handle-curr' : '') + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="' + i + '"></span>' + (hasTooltip ? '<span class="mbsc-slider-tooltip"></span>' : '') + '</span>');
      });
      $tooltips = $parent.find('.mbsc-slider-tooltip');
    };

    that.___init = function () {
      if ($parent) {
        $parent.removeClass('mbsc-slider-has-tooltip');

        if (step != 1) {
          $$1('.mbsc-slider-step', $track).remove();
        }
      }

      $parent = that._$parent;
      $track = that._$track;
      $progress = that._$progress;
      $elm = $parent.find('input');
      s = that.settings;
      min = that._min;
      max = that._max;
      that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;
      that._live = getBoolAttr('data-live', s.live, $elm);
      hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);
      hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;
      isRange = hasProgress && $elm.length == 2;
      isRtl = s.rtl;

      that._markupReady();
    };

    if (!inherit) {
      that.init();
    }
  };
  Slider.prototype = {
    _class: 'progress',
    _css: 'mbsc-progress mbsc-slider',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      changeEvent: 'change',
      stopProp: true,
      min: 0,
      max: 100,
      step: 1,
      live: true,
      highlight: true,
      round: true,
      returnAffix: true
    }
  };
  classes.Slider = Slider; // Init mbsc-slider elements on page load

  autoInit('[mbsc-slider]', Slider);

  var Rating = function Rating(elm, settings, inherit) {
    var $progress,
        $track,
        max,
        min,
        empty,
        filled,
        s,
        that = this,
        $elm = $$1(elm); // Call the parent constructor

    Slider.call(this, elm, settings, true);

    that._update = function (v, value, index, percent, multiple, refresh) {
      $progress.css('width', getPercent(v, 0, max) + '%'); // Display value in the specified container(s)

      if (!multiple && (value[index] != v || refresh)) {
        that._display(v);
      } // Return validated value


      return v;
    };

    that._markupReady = function () {
      var i,
          emptyString = '',
          filledString = '';
      $track = that._$track;
      $progress = that._$progress;
      s = that.settings;
      min = that._min;
      max = that._max;
      that._base = min;
      that._rounding = s.rtl ? 'floor' : 'ceil';
      empty = $elm.attr('data-empty') || s.empty;
      filled = $elm.attr('data-filled') || s.filled;

      for (i = 0; i < max; ++i) {
        emptyString += '<span class="mbsc-ic mbsc-ic-' + empty + '"></span>';
        filledString += '<span class="mbsc-ic mbsc-ic-' + filled + '"></span>';
      }

      $track.html(emptyString);
      $track.append($progress);
      $progress.html(filledString);
      $track.append('<span class="mbsc-rating-handle-cont' + '">' + '<span tabindex="0" class="mbsc-slider-handle" aria-valuemin="' + min + '" aria-valuemax="' + max + '" data-index="0"></span>' + '</span>');
    };

    if (!inherit) {
      that.init();
    }
  };
  Rating.prototype = {
    _class: 'progress',
    _css: 'mbsc-progress mbsc-rating',
    _hasTheme: true,
    _hasLang: true,
    _hasDef: true,
    _defaults: {
      changeEvent: 'change',
      stopProp: true,
      min: 1,
      max: 5,
      step: 1,
      live: true,
      round: true,
      hover: true,
      highlight: true,
      returnAffix: true,
      empty: 'star',
      filled: 'star3'
    }
  };
  classes.Rating = Rating; // Init mbsc-rating elements on page load

  autoInit('[mbsc-rating]', Rating);

  var nr = 1;
  var CollapsibleBase =
  /*#__PURE__*/
  function () {
    function CollapsibleBase(elm, settings) {
      var _this = this;

      var content;
      var $header;
      var $content;
      var $elm = $$1(elm);
      this.settings = settings;
      this._isOpen = settings.isOpen || false;
      $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));

      if ($elm.hasClass('mbsc-card')) {
        // card enhance
        $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');
        $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');
      } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {
        // form group enhance
        $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');
        $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');
      } else {
        // if it is used independently
        $header = $elm.find('.mbsc-collapsible-header').eq(0);
        $content = $elm.find('.mbsc-collapsible-content').eq(0);
      }

      content = $content[0];

      if (content && !content.id) {
        content.id = 'mbsc-collapsible-' + nr++;
      }

      if ($header.length && content) {
        var $collapsibleIcon = $$1('<span class="mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5"></span>');
        tap(this, $header, function () {
          _this.collapse();
        });
        $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', this.onMouseDown).on('keydown', this.onKeyDown).append($collapsibleIcon);
      }

      elm.mbscInst = this;
      this._$header = $header;
      this._$content = $content;
      this._$elm = $elm;
      this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');
      this.show = this.show.bind(this);
      this.hide = this.hide.bind(this);
      this.toggle = this.toggle.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.onMouseDown = this.onMouseDown.bind(this);
    }

    var _proto = CollapsibleBase.prototype;

    _proto.collapse = function collapse(show) {
      var $elm = this._$elm;
      var $content = this._$content;

      var removeHeight = function removeHeight() {
        $content.off('transitionend', removeHeight).css('height', '');
      };

      if (show === undefined) {
        show = !this._isOpen;
      }

      if (show && this._isOpen || !show && !this._isOpen || !$content.length) {
        return;
      }

      if (show) {
        if (hasTransition) {
          $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);
        }

        $elm.addClass('mbsc-collapsible-open');
      } else {
        if (hasTransition) {
          $content.css('height', getComputedStyle($content[0]).height);
        }

        setTimeout(function () {
          $content.css('height', 0);
          $elm.removeClass('mbsc-collapsible-open');
        }, 50);
      }

      if (show && this._$accordionParent) {
        this._$accordionParent.find('.mbsc-collapsible-open').each(function () {
          if (this !== $elm[0]) {
            this.mbscInst.hide();
          }
        });
      }

      this._isOpen = show;

      this._$header.attr('aria-expanded', this._isOpen);
    };

    _proto.show = function show() {
      this.collapse(true);
    };

    _proto.hide = function hide() {
      this.collapse(false);
    };

    _proto.toggle = function toggle() {
      this.collapse();
    };

    _proto.destroy = function destroy() {
      this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');

      this._$content.removeClass('mbsc-collapsible-content');

      this._$header.removeClass('mbsc-collapsible-header').off('mousedown', this.onMouseDown).off('keydown', this.onKeyDown).find('.mbsc-collapsible-icon').remove();

      tapOff(this._$header);
    };

    _proto.onKeyDown = function onKeyDown(ev) {
      if (ev.which === 32 || ev.keyCode == 13) {
        //space or enter 
        ev.preventDefault();
        this.collapse();
      }
    };

    _proto.onMouseDown = function onMouseDown(ev) {
      // prevent focus on mouse down
      ev.preventDefault();
    };

    return CollapsibleBase;
  }();
  classes.CollapsibleBase = CollapsibleBase;

  var id$1 = 0;

  function initControls($ctx, controls, s, shallow) {
    $$1('input,select,textarea,progress,button', $ctx).each(function () {
      var control = this,
          $control = $$1(control),
          //$parent = $control.parent(),
      type = getControlType($control); // Skip elements with data-enhance="false"

      if ($control.attr('data-enhance') != 'false'
      /* TRIALCOND */
      ) {
          if ($control.hasClass('mbsc-control')) {
            if (control.mbscInst) {
              control.mbscInst.option({
                theme: s.theme,
                lang: s.lang,
                rtl: s.rtl,
                onText: s.onText,
                offText: s.offText,
                stopProp: s.stopProp
              });
            }
          } else {
            if (!control.id) {
              control.id = 'mbsc-form-control-' + ++id$1;
            }

            switch (type) {
              case 'button':
              case 'submit':
                controls[control.id] = new Button(control, {
                  theme: s.theme,
                  rtl: s.rtl,
                  tap: s.tap
                });
                break;

              case 'switch':
                controls[control.id] = new Switch(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  tap: s.tap,
                  onText: s.onText,
                  offText: s.offText,
                  stopProp: s.stopProp
                });
                break;

              case 'checkbox':
                controls[control.id] = new CheckBox(control, {
                  tap: s.tap,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'range':
                if (!$$1(control).parent().hasClass('mbsc-slider')) {
                  controls[control.id] = new Slider(control, {
                    theme: s.theme,
                    lang: s.lang,
                    rtl: s.rtl,
                    stopProp: s.stopProp,
                    labelStyle: s.labelStyle
                  });
                }

                break;

              case 'rating':
                controls[control.id] = new Rating(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  stopProp: s.stopProp
                });
                break;

              case 'progress':
                controls[control.id] = new Progress(control, {
                  theme: s.theme,
                  lang: s.lang,
                  rtl: s.rtl,
                  labelStyle: s.labelStyle
                });
                break;

              case 'radio':
                controls[control.id] = new Radio(control, {
                  tap: s.tap,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'select':
              case 'select-one':
              case 'select-multiple':
                controls[control.id] = new Select(control, {
                  tap: s.tap,
                  inputStyle: s.inputStyle,
                  labelStyle: s.labelStyle,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'textarea':
                controls[control.id] = new TextArea(control, {
                  tap: s.tap,
                  inputStyle: s.inputStyle,
                  labelStyle: s.labelStyle,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'segmented':
                controls[control.id] = new SegmentedItem(control, {
                  theme: s.theme,
                  rtl: s.rtl,
                  tap: s.tap,
                  inputStyle: s.inputStyle
                });
                break;

              case 'stepper':
                controls[control.id] = new Stepper(control, {
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;

              case 'hidden':
                return;

              default:
                controls[control.id] = new Input(control, {
                  tap: s.tap,
                  inputStyle: s.inputStyle,
                  labelStyle: s.labelStyle,
                  theme: s.theme,
                  rtl: s.rtl
                });
                break;
            }
          }
        }
    });
    $$1('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {
      var control = this,
          $control = $$1(control),
          isOpen = $control.attr('data-open');

      if (!control.id) {
        control.id = 'mbsc-form-control-' + ++id$1;
      }

      controls[control.id] = new CollapsibleBase(control, {
        isOpen: isOpen !== undefined && isOpen != 'false'
      });
      instances[control.id] = controls[control.id];
    }); // Set initial height for textareas

    if (!shallow) {
      sizeTextAreas();
    }
  }

  var innerStyle = 'position:absolute;left:0;top:0;';
  var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
  var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';
  var observer;
  var count = 0;
  function resizeObserver(el, callback, zone) {
    function reset() {
      expandChild.style.width = '100000px';
      expandChild.style.height = '100000px';
      expand.scrollLeft = 100000;
      expand.scrollTop = 100000;
      shrink.scrollLeft = 100000;
      shrink.scrollTop = 100000;
    }

    function checkHidden() {
      var now = new Date();
      hiddenRafId = 0;

      if (!stopCheck) {
        if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
          lastCheck = now;
          reset();
        }

        if (!hiddenRafId) {
          hiddenRafId = raf(checkHidden);
        }
      }
    }

    function onScroll() {
      if (!rafId) {
        rafId = raf(onResize);
      }
    }

    function onResize() {
      rafId = 0;
      reset();
      callback();
    }

    var expand;
    var expandChild;
    var helper;
    var hiddenRafId;
    var rafId;
    var shrink;
    var stopCheck;
    var lastCheck = 0; //let isHidden = true;

    if (window.ResizeObserver) {
      if (!observer) {
        observer = new ResizeObserver(function (entries) {
          for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            var entry = _ref;

            entry.target.__mbscResize();
          }
        });
      }

      count++;
      el.__mbscResize = callback;
      observer.observe(el);
    } else {
      helper = document.createElement('div');
      helper.innerHTML = markup;
      helper.dir = 'ltr'; // Need this to work in rtl as well;

      shrink = helper.childNodes[1];
      expand = helper.childNodes[0];
      expandChild = expand.childNodes[0];
      el.appendChild(helper);
      expand.addEventListener('scroll', onScroll);
      shrink.addEventListener('scroll', onScroll);

      if (zone) {
        zone.runOutsideAngular(function () {
          raf(checkHidden);
        });
      } else {
        raf(checkHidden);
      }
    }

    return {
      detach: function detach() {
        if (observer) {
          count--;
          observer.unobserve(el);

          if (!count) {
            observer = null;
          }
        } else {
          el.removeChild(helper);
          stopCheck = true;
        }
      }
    };
  }

  var $activeElm,
      preventShow,
      themes = mobiscroll.themes,
      needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,
      isAndroid = os == 'android',
      isIOS = os == 'ios',
      isIOS8 = isIOS && majorVersion == 8,
      halfBorder = isIOS && majorVersion > 7,
      prevdef = function prevdef(ev) {
    ev.preventDefault();
  };

  var EDITABLE = 'input,select,textarea,button';
  var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
  var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
  var Frame = function Frame(el, settings, inherit) {
    var //$ariaDiv,
    $ctx,
        $header,
        $lock,
        $markup,
        $overlay,
        $persp,
        $popup,
        $wnd,
        $wrapper,
        buttons,
        btn,
        ctx,
        doAnim,
        hasContext,
        isModal,
        isInserted,
        isPointer,
        markup,
        modalWidth,
        modalHeight,
        needsDimensions,
        needsLock,
        observer,
        overlay,
        popup,
        posDebounce,
        prevInst,
        s,
        scrollLock,
        touched,
        trigger,
        wndWidth,
        wndHeight,
        that = this,
        $elm = $$1(el),
        elmList = [],
        lastFocus = new Date();

    function onBtnStart(ev) {
      // Need this to prevent opening of sidemenus or similar
      if (s.stopProp) {
        ev.stopPropagation();
      }

      var b = closest(this, ev.target, '.mbsc-fr-btn-e');

      if (!b) {
        return;
      } // Can't call preventDefault here, it kills page scroll


      if (btn) {
        btn.removeClass('mbsc-active');
      }

      btn = $$1(b); // Active button

      if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
        btn.addClass('mbsc-active');
      }

      if (ev.type === 'mousedown') {
        $$1(document).on('mouseup', onBtnEnd);
      }
    }

    function onBtnEnd(ev) {
      if (btn) {
        btn.removeClass('mbsc-active');
        btn = null;
      }

      if (ev.type === 'mouseup') {
        $$1(document).off('mouseup', onBtnEnd);
      }
    }

    function onScroll(ev) {
      if (scrollLock && markup.contains(ev.target)) {
        ev.preventDefault();
      }
    }

    function onWndKeyDown(ev) {
      if (mobiscroll.activeInstance == that) {
        if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
          that.select();
        } else if (ev.keyCode == 27) {
          that.cancel();
        }
      }
    }

    function onShow(prevFocus) {
      if (!prevFocus && !isAndroid && that._activeElm) {
        //overlay.focus();
        lastFocus = new Date();

        that._activeElm.focus();
      } //that.ariaMessage(s.ariaMessage);

    }

    function onHide(prevAnim) {
      var $activeEl = $activeElm,
          focus = s.focusOnClose;

      that._markupRemove();

      $markup.remove();

      if (isModal) {
        ctx.mbscModals--;

        if (s.scrollLock) {
          ctx.mbscLock--;
        }

        if (!ctx.mbscLock) {
          $lock.removeClass('mbsc-fr-lock');
        }

        if (needsLock) {
          ctx.mbscIOSLock--;

          if (!ctx.mbscIOSLock) {
            $lock.removeClass('mbsc-fr-lock-ios');
            $ctx.css({
              top: '',
              left: ''
            });
            $wnd.scrollLeft(ctx.mbscScrollLeft);
            $wnd.scrollTop(ctx.mbscScrollTop);
          }
        } // The follwing should be done only if no other
        // instance was opened during the hide animation


        if (!ctx.mbscModals) {
          $lock.removeClass('mbsc-fr-lock-ctx');
        }

        if (!ctx.mbscModals || prevInst) {
          // Put focus back to the last active element
          if (!prevAnim) {
            if (!$activeEl) {
              $activeEl = $elm;
            }

            setTimeout(function () {
              if (focus === undefined || focus === true) {
                preventShow = true;
                $activeEl[0].focus();
              } else if (focus) {
                $$1(focus)[0].focus();
              }
            }, 200);
          }
        }
      }

      prevInst = undefined;
      isInserted = false;
      trigger('onHide');
    }

    function onPosition() {
      clearTimeout(posDebounce);
      posDebounce = setTimeout(function () {
        if (that.position(true)) {
          // Trigger reflow, needed on iOS safari, when orientation is changed
          popup.style.visibility = 'hidden';
          popup.offsetHeight;
          popup.style.visibility = '';
        }
      }, 200);
    }

    function onFocus(ev) {
      if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
        lastFocus = new Date();

        that._activeElm.focus();
      }
    }

    function insertMarkup(prevAnim, prevFocus) {
      function onAnimEnd() {
        $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
        onShow(prevFocus);
      }

      function onOverlayStart(ev) {
        if (!target && ev.target == overlay) {
          target = true;
          moved = false;
          startX = getCoord(ev, 'X');
          startY = getCoord(ev, 'Y');
        }
      }

      function onOverlayMove(ev) {
        if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
          moved = true;
        }
      } // Might be not visible if immediately hidden


      if (!that._isVisible) {
        return;
      } // Show


      if (isModal) {
        $markup.appendTo($ctx);
      } else if ($elm.is('div') && !that._hasContent) {
        // Insert inside the element on which was initialized
        $elm.empty().append($markup);
      } else {
        // Insert after the element
        if ($elm.hasClass('mbsc-control')) {
          var $wrap = $elm.closest('.mbsc-control-w');
          $markup.insertAfter($wrap);

          if ($wrap.hasClass('mbsc-select')) {
            $wrap.addClass('mbsc-select-inline');
          }
        } else {
          $markup.insertAfter($elm);
        }
      }

      isInserted = true;

      that._markupInserted($markup);

      trigger('onMarkupInserted', {
        target: markup
      });

      if (isModal && s.closeOnOverlayTap) {
        var moved, target, startX, startY;
        listen(overlay, 'touchstart', onOverlayStart, {
          passive: true
        });
        listen(overlay, 'touchmove', onOverlayMove, {
          passive: true
        });
        $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {
          target = false;
        }).on('touchend click', function (ev) {
          if (target && !moved) {
            that.cancel();

            if (ev.type == 'touchend') {
              preventClick();
            }
          }

          target = false;
        });
      }

      $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
        if (ev.keyCode == 32) {
          // Space
          ev.preventDefault();
          ev.stopPropagation();
          this.click();
        }
      }).on('keydown', function (ev) {
        // Trap focus inside modal
        if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {
          // Prevent page scroll on space press
          ev.preventDefault();
        } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
          // Tab
          var $focusable = $markup.find(FOCUSABLE).filter(function () {
            return this.offsetWidth > 0 || this.offsetHeight > 0;
          }),
              index = $focusable.index($$1(':focus', $markup)),
              i = $focusable.length - 1,
              target = 0;

          if (ev.shiftKey) {
            i = 0;
            target = -1;
          }

          if (index === i) {
            $focusable.eq(target)[0].focus();
            ev.preventDefault();
          }
        }
      }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);
      listen(markup, 'touchstart', onBtnStart, {
        passive: true
      });
      listen(markup, 'mousedown', onBtnStart); // Need event capture for this

      listen(markup, 'touchstart', function () {
        if (!touched) {
          touched = true;
          $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
        }
      }, {
        passive: true,
        capture: true
      }); // Init buttons

      $$1.each(buttons, function (i, b) {
        that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {
          b = isString(b) ? that.buttons[b] : b;
          (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
        }, true);
      });

      that._attachEvents($markup); // Set position


      if (that.position() === false) {
        return;
      }

      if (isModal || that._checkSize) {
        observer = resizeObserver(markup, onPosition, s.zone);
      }

      if (isModal) {
        $markup.removeClass('mbsc-fr-pos');

        if (doAnim && !prevAnim) {
          $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
        } else {
          onShow(prevFocus);
        }
      }

      trigger('onShow', {
        target: markup,
        valueText: that._tempValue
      });
    }

    function show(beforeShow, $elm) {
      if (that._isVisible) {
        return;
      }

      if (beforeShow) {
        beforeShow();
      }

      if (that.show() !== false) {
        $activeElm = $elm;
      }
    }

    function set() {
      that._fillValue();

      trigger('onSet', {
        valueText: that._value
      });
    }

    function cancel() {
      trigger('onCancel', {
        valueText: that._value
      });
    }

    function clear() {
      that.setVal(null, true);
    } // Call the parent constructor


    Base.call(this, el, settings, true);
    /**
     * Positions the scroller on the screen.
     */

    that.position = function (check) {
      var anchor,
          anchorWidth,
          anchorHeight,
          anchorPos,
          anchorTop,
          anchorLeft,
          arrow,
          arrowWidth,
          arrowHeight,
          docHeight,
          docWidth,
          isWrapped,
          newHeight,
          newWidth,
          oldHeight,
          oldWidth,
          width,
          top,
          left,
          css = {},
          scrollLeft = 0,
          scrollTop = 0,
          minWidth = 0,
          totalWidth = 0;

      if (!isInserted) {
        return false;
      }

      oldWidth = wndWidth;
      oldHeight = wndHeight;
      newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);
      newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);

      if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
        return;
      }

      if (that._checkResp(newWidth)) {
        return false;
      }

      wndWidth = newWidth;
      wndHeight = newHeight;

      if (that._isFullScreen || /top|bottom/.test(s.display)) {
        // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
        $popup.width(newWidth);
      } else if (isModal) {
        // Reset width
        $wrapper.width('');
      }

      that._position($markup); // Call position for nested mobiscroll components
      // $('.mbsc-comp', $markup).each(function () {
      //     var inst = instances[this.id];
      //     if (inst && inst !== that && inst.position) {
      //         inst.position();
      //     }
      // });


      if (!that._isFullScreen && /center|bubble/.test(s.display)) {
        $$1('.mbsc-w-p', $markup).each(function () {
          // Need fractional values here, so offsetWidth is not ok
          width = this.getBoundingClientRect().width;
          totalWidth += width;
          minWidth = width > minWidth ? width : minWidth;
        });
        isWrapped = totalWidth > newWidth - 16 || s.tabs === true;
        $wrapper.css({
          'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
          'white-space': isWrapped ? '' : 'nowrap'
        });
      }

      if (trigger('onPosition', {
        target: markup,
        popup: popup,
        hasTabs: isWrapped,
        oldWidth: oldWidth,
        oldHeight: oldHeight,
        windowWidth: newWidth,
        windowHeight: newHeight
      }) === false || !isModal) {
        return;
      }

      if (needsDimensions) {
        scrollLeft = $wnd.scrollLeft();
        scrollTop = $wnd.scrollTop();

        if (wndWidth) {
          $persp.css({
            width: '',
            height: ''
          });
        }
      }

      modalWidth = popup.offsetWidth;
      modalHeight = popup.offsetHeight;
      scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

      if (s.display == 'center') {
        left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
        top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
      } else if (s.display == 'bubble') {
        anchor = s.anchor === undefined ? $elm : $$1(s.anchor);
        arrow = $$1('.mbsc-fr-arr-i', $markup)[0];
        anchorPos = anchor.offset();
        anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
        anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);
        anchorWidth = anchor[0].offsetWidth;
        anchorHeight = anchor[0].offsetHeight;
        arrowWidth = arrow.offsetWidth;
        arrowHeight = arrow.offsetHeight; // Horizontal positioning

        left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning
        // Below the input

        top = anchorTop + anchorHeight + arrowHeight / 2;

        if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
          $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input

          top = anchorTop - modalHeight - arrowHeight / 2;
        } else {
          $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
        } // Set arrow position


        $$1('.mbsc-fr-arr', $markup).css({
          left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
        }); // Lock scroll only if popup is entirely in the viewport

        scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
      } else {
        left = scrollLeft;
        top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
      }

      if (needsDimensions) {
        // If top + modal height > doc height, increase doc height
        docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());
        docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());
        $persp.css({
          width: docWidth,
          height: docHeight
        }); // Check if scroll needed

        if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
          $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
        }
      }

      css.top = Math.floor(top);
      css.left = Math.floor(left);
      $popup.css(css);
      return true;
    };
    /**
     * Show mobiscroll on focus and click event of the parameter.
     * @param {HTMLElement} elm - Events will be attached to this element.
     * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
     */


    that.attachShow = function (elm, beforeShow) {
      var $label,
          $elm = $$1(elm).off('.mbsc'),
          readOnly = $elm.prop('readonly');
      tapOff($elm);

      if (s.display !== 'inline') {
        if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
          $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
            // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
            ev.preventDefault();
          }).on('focus.mbsc', function () {
            if (that._isVisible) {
              // Don't allow input focus if mobiscroll is being opened
              this.blur();
            }
          });
          $label = $$1('label[for="' + $elm.attr('id') + '"]');

          if (!$label.length) {
            $label = $elm.closest('label');
          }
        }

        if (!$elm.is('select')) {
          if (s.showOnFocus) {
            $elm.on('focus.mbsc', function () {
              if (!preventShow) {
                show(beforeShow, $elm);
              } else {
                preventShow = false;
              }
            });
          }

          if (s.showOnTap) {
            $elm.on('keydown.mbsc', function (ev) {
              if (ev.keyCode == 32 || ev.keyCode == 13) {
                // Space or Enter
                ev.preventDefault();
                ev.stopPropagation();
                show(beforeShow, $elm);
              }
            });
            that.tap($elm, function (ev) {
              if (ev.isMbscTap) {
                touched = true;
              }

              show(beforeShow, $elm);
            });

            if ($label && $label.length) {
              tapOff($label);
              that.tap($label, function (ev) {
                ev.preventDefault();

                if (ev.target !== $elm[0]) {
                  show(beforeShow, $elm);
                }
              });
            }
          }
        }

        elmList.push({
          readOnly: readOnly,
          el: $elm,
          lbl: $label
        });
      }
    };
    /**
     * Set button handler.
     */


    that.select = function () {
      if (isModal) {
        that.hide(false, 'set', false, set);
      } else {
        set();
      }
    };
    /**
     * Cancel and hide the scroller instance.
     */


    that.cancel = function () {
      if (isModal) {
        that.hide(false, 'cancel', false, cancel);
      } else {
        cancel();
      }
    };
    /**
     * Clear button handler.
     */


    that.clear = function () {
      that._clearValue();

      trigger('onClear');

      if (isModal && that._isVisible && !that.live) {
        that.hide(false, 'clear', false, clear);
      } else {
        clear();
      }
    };
    /**
     * Enables the scroller and the associated input.
     */


    that.enable = function () {
      s.disabled = false;
      $$1.each(elmList, function (i, v) {
        if (v.el.is('input,select')) {
          v.el[0].disabled = false;
        }
      });
    };
    /**
     * Disables the scroller and the associated input.
     */


    that.disable = function () {
      s.disabled = true;
      $$1.each(elmList, function (i, v) {
        if (v.el.is('input,select')) {
          v.el[0].disabled = true;
        }
      });
    };
    /**
     * Shows the scroller instance.
     * @param {Boolean} prevAnim - Prevent animation if true
     * @param {Boolean} prevFocus - Prevent focusing if true
     */


    that.show = function (prevAnim, prevFocus) {
      var hasButtons, html, scrollLeft, scrollTop;

      if (s.disabled || that._isVisible) {
        return;
      } // Parse value from input


      that._readValue();

      if (trigger('onBeforeShow') === false) {
        return false;
      }

      $activeElm = null;
      doAnim = s.animate;
      buttons = s.buttons || [];
      needsDimensions = hasContext || s.display == 'bubble';
      needsLock = needsFixed && !needsDimensions && s.scrollLock;
      hasButtons = buttons.length > 0; //touched = false;

      if (doAnim !== false) {
        if (s.display == 'top') {
          doAnim = doAnim || 'slidedown';
        } else if (s.display == 'bottom') {
          doAnim = doAnim || 'slideup';
        } else if (s.display == 'center' || s.display == 'bubble') {
          doAnim = doAnim || 'pop';
        }
      }

      if (isModal) {
        wndWidth = 0;
        wndHeight = 0;

        if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
          //$lock.scrollTop(0);
          ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
          ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
          $ctx.css({
            top: -scrollTop + 'px',
            left: -scrollLeft + 'px'
          });
        }

        $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard

        if ($$1(document.activeElement).is('input,textarea')) {
          document.activeElement.blur();
        } // Save active instance to previous


        prevInst = mobiscroll.activeInstance; // Set active instance

        mobiscroll.activeInstance = that; // Keep track of modals opened per context

        ctx.mbscModals = (ctx.mbscModals || 0) + 1;

        if (needsLock) {
          ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
        }

        if (s.scrollLock) {
          ctx.mbscLock = (ctx.mbscLock || 0) + 1;
        }
      } // Create wheels containers


      html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '">' + (isModal ? '<div class="mbsc-fr-persp">' + (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
      '<div role="dialog" class="mbsc-fr-scroll">' : '') + '<div class="mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
      s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + ( // Bubble arrow
      isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') + '<div class="mbsc-fr-w">' + ( // Popup content
      //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
      s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
      '<div class="mbsc-fr-c">'; // Wheel group container

      html += that._generateContent();
      html += '</div>';

      if (hasButtons) {
        var b,
            i,
            j,
            l = buttons.length;
        html += '<div class="mbsc-fr-btn-cont">';

        for (i = 0; i < buttons.length; i++) {
          j = s.btnReverse ? l - i - 1 : i;
          b = buttons[j];
          b = isString(b) ? that.buttons[b] : b;

          if (b.handler === 'set') {
            b.parentClass = 'mbsc-fr-btn-s';
          }

          if (b.handler === 'cancel') {
            b.parentClass = 'mbsc-fr-btn-c';
          }

          html += '<div' + (s.btnWidth ? ' style="width:' + 100 / buttons.length + '%"' : '') + ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' + '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
        }

        html += '</div>';
      }

      html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');
      $markup = $$1(html);
      $persp = $$1('.mbsc-fr-persp', $markup);
      $overlay = $$1('.mbsc-fr-scroll', $markup);
      $wrapper = $$1('.mbsc-fr-w', $markup);
      $popup = $$1('.mbsc-fr-popup', $markup);
      $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);

      markup = $markup[0];
      overlay = $overlay[0];
      popup = $popup[0];
      that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];
      that._markup = $markup;
      that._isVisible = true;
      that.markup = markup;

      that._markupReady($markup);

      trigger('onMarkupReady', {
        target: markup
      }); // Attach events

      if (isModal) {
        // Enter / ESC
        $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise

        if (s.scrollLock) {
          listen(document, 'touchmove', onScroll, {
            passive: false
          });
          listen(document, 'mousewheel', onScroll, {
            passive: false
          });
          listen(document, 'wheel', onScroll, {
            passive: false
          });
        }

        if (s.focusTrap) {
          $wnd.on('focusin', onFocus);
        }
      }

      if (isModal) {
        // Wait for the toolbar and addressbar to appear on iOS
        setTimeout(function () {
          insertMarkup(prevAnim, prevFocus);
        }, needsLock ? 100 : 0);
      } else {
        insertMarkup(prevAnim, prevFocus);
      }
    };
    /**
     * Hides the scroller instance.
     */


    that.hide = function (prevAnim, btn, force, callback) {
      function onAnimEnd() {
        $markup.off(animEnd, onAnimEnd);
        onHide(prevAnim);
      } // If onClose handler returns false, prevent hide


      if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
        valueText: that._tempValue,
        button: btn
      }) === false) {
        return false;
      }

      that._isVisible = false;

      if (observer) {
        observer.detach();
        observer = null;
      }

      if (isModal) {
        if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
          document.activeElement.blur();
        }

        if (mobiscroll.activeInstance == that) {
          mobiscroll.activeInstance = prevInst;
        }

        $$1(window).off('keydown', onWndKeyDown);
        $wnd.off('focusin', onFocus);
        unlisten(document, 'touchmove', onScroll, {
          passive: false
        });
        unlisten(document, 'mousewheel', onScroll, {
          passive: false
        });
        unlisten(document, 'wheel', onScroll, {
          passive: false
        });
      } // Hide wheels and overlay


      if ($markup) {
        if (isModal && isInserted && doAnim && !prevAnim) {
          $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
        } else {
          onHide(prevAnim);
        }

        that._detachEvents($markup);
      }

      if (callback) {
        callback();
      } // For validation


      $elm.trigger('blur');
      trigger('onClose', {
        valueText: that._value
      });
    }; // that.ariaMessage = function (txt) {
    //     $ariaDiv.html('');
    //     setTimeout(function () {
    //         $ariaDiv.html(txt);
    //     }, 100);
    // };

    /**
     * Return true if the scroller is currently visible.
     */


    that.isVisible = function () {
      return that._isVisible;
    }; // Protected functions to override


    that.setVal = noop;
    that.getVal = noop;
    that._generateContent = noop;
    that._attachEvents = noop;
    that._detachEvents = noop;
    that._readValue = noop;
    that._clearValue = noop;
    that._fillValue = noop;
    that._markupReady = noop;
    that._markupInserted = noop;
    that._markupRemove = noop;
    that._position = noop;
    that.__processSettings = noop;
    that.__init = noop;
    that.__destroy = noop; // Generic frame functions

    /**
     * Destroys the mobiscroll instance.
     */

    that._destroy = function () {
      // Force hide without animation
      that.hide(true, false, true);
      $elm.off('.mbsc');
      tapOff($elm); // Remove all events from elements

      $$1.each(elmList, function (i, v) {
        v.el.off('.mbsc').prop('readonly', v.readOnly);
        tapOff(v.el);

        if (v.lbl) {
          v.lbl.off('.mbsc');
          tapOff(v.lbl);
        }
      });

      that.__destroy();
    };

    that._updateHeader = function () {
      var t = s.headerText,
          txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
      $header.html(txt || '&nbsp;');
    };

    that._getRespCont = function () {
      hasContext = s.context != 'body';
      $wnd = $$1(hasContext ? s.context : window);
      return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;
    };

    that._processSettings = function (resp) {
      var b, i;

      that.__processSettings(resp);

      isPointer = !s.touchUi;

      if (isPointer) {
        s.display = resp.display || settings.display || 'bubble';
        s.buttons = resp.buttons || settings.buttons || [];
        s.showOverlay = resp.showOverlay || settings.showOverlay || false;
      } // Add default buttons


      s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default

      s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;
      buttons = s.buttons || [];
      isModal = s.display !== 'inline';
      $ctx = $$1(s.context);
      $lock = hasContext ? $ctx : $$1('body,html');
      ctx = $ctx[0];
      that.live = true; // If no set button is found, live mode is activated

      for (i = 0; i < buttons.length; i++) {
        b = buttons[i];

        if (b == 'ok' || b == 'set' || b.handler == 'set') {
          that.live = false;
        }
      }

      that.buttons.set = {
        text: s.setText,
        icon: s.setIcon,
        handler: 'set'
      };
      that.buttons.cancel = {
        text: s.cancelText,
        icon: s.cancelIcon,
        handler: 'cancel'
      };
      that.buttons.close = {
        text: s.closeText,
        icon: s.closeIcon,
        handler: 'cancel'
      };
      that.buttons.clear = {
        text: s.clearText,
        icon: s.clearIcon,
        handler: 'clear'
      };
      that._isInput = $elm.is('input');
    };
    /**
     * Scroller initialization.
     */


    that._init = function (newSettings) {
      var wasVisible = that._isVisible,
          wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

      if (wasVisible) {
        that.hide(true, false, true);
      } // Unbind all events (if re-init)


      $elm.off('.mbsc');
      tapOff($elm);

      that.__init(newSettings);

      that._isLiquid = s.layout == 'liquid';

      if (isModal) {
        that._readValue();

        if (!that._hasContent && !s.skipShow) {
          that.attachShow($elm);
        }

        if (wasVisible) {
          that.show(wasReady);
        }
      } else {
        that.show();
      }

      $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
        if (!that._preventChange) {
          that.setVal($elm.val(), true, false);
        }

        that._preventChange = false;
      });
    };

    that.buttons = {};
    that.handlers = {
      set: that.select,
      cancel: that.cancel,
      clear: that.clear
    };
    that._value = null;
    that._isValid = true;
    that._isVisible = false; // Constructor

    s = that.settings;
    trigger = that.trigger;

    if (!inherit) {
      that.init();
    }
  };
  Frame.prototype._defaults = {
    // Localization
    lang: 'en',
    setText: 'Set',
    selectedText: '{count} selected',
    closeText: 'Close',
    cancelText: 'Cancel',
    clearText: 'Clear',
    // Options
    context: 'body',
    maxPopupWidth: 600,
    disabled: false,
    closeOnOverlayTap: true,
    showOnFocus: isAndroid || isIOS,
    // Needed for ion-input
    showOnTap: true,
    display: 'center',
    scroll: true,
    scrollLock: true,
    showOverlay: true,
    tap: true,
    touchUi: true,
    btnClass: 'mbsc-fr-btn',
    btnWidth: true,
    focusTrap: true,
    focusOnClose: !isIOS8 // Temporary for iOS8

  };
  classes.Frame = Frame;
  themes.frame.mobiscroll = {
    headerText: false,
    btnWidth: false
  };
  themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
    rows: 5,
    showLabel: false,
    selectedLineBorder: 1,
    weekDays: 'min',
    checkIcon: 'ion-ios7-checkmark-empty',
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
  });

  if (isBrowser) {
    // Prevent re-show on window focus
    $$1(window).on('focus', function () {
      if ($activeElm) {
        preventShow = true;
      }
    });
  }

  var Popup = function Popup(el, settings, inherit) {
    function addContent($m) {
      /* TRIAL */
      if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c')
      /* TRIALCOND */
      ) {
          $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

          if (!$$1('.mbsc-w-p', $m).length) {
            $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');
          }
        }
    }

    var s,
        $prev,
        $elm = $$1(el),
        that = this; // Call the parent constructor

    Frame.call(this, el, settings, true);
    /* TRIALFUNC */

    that._generateContent = function () {
      return '';
    };

    that._markupReady = function ($m) {
      if (s.display != 'inline') {
        addContent($m);
      }
    };

    that._markupInserted = function ($m) {
      if (s.display == 'inline') {
        addContent($m);
      }

      $m.trigger('mbsc-enhance', [{
        theme: s.theme,
        lang: s.lang
      }]);
    };

    that._markupRemove = function () {
      $elm.hide();

      if ($prev && $prev.parent().length) {
        $prev.after($elm);
      }
    };

    that.__processSettings = function () {
      s = that.settings;
      that.buttons.ok = {
        text: s.okText,
        icon: s.okIcon,
        handler: 'set'
      };
      s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

      if (!$prev && $elm.parent().length) {
        $prev = $$1(document.createComment('popup'));
        $elm.before($prev);
      }

      $elm.hide();
    }; // Constructor


    if (!inherit) {
      that.init();
    }
  };
  Popup.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasContent: true,
    _hasLang: true,
    _responsive: true,
    _class: 'popup',
    _defaults: extend$1({}, Frame.prototype._defaults, {
      compClass: 'mbsc-wdg',
      okText: 'OK',
      headerText: false
    })
  };
  classes.Popup = Popup;
  classes.Widget = Popup;
  mobiscroll.themes.popup = mobiscroll.themes.frame;

  var hasPromise = isBrowser && !!window.Promise;
  var popupQueue = [];
  var notificationQueue = [];
  var activeNotification;

  function showPopup(popup) {
    if (!popupQueue.length) {
      popup.show();
    }

    popupQueue.push(popup);
  }

  function showNotification(notification) {
    var isAny = notificationQueue.length;
    notificationQueue.push(notification); // Only show notification if no popup is visible
    // otherwise postpone it until popup is closed

    if (!popupQueue.length) {
      // If there's a visible notification, hide it.
      // The notification will be shown after hide animation is complete
      if (isAny) {
        notificationQueue[0].hide();
      } else {
        // Prevent focus on show for notifications
        notification.show(false, true);
      }
    }
  }

  function getSettings(queue, settings, resolve, more) {
    //const active = mobiscroll.activeInstance;
    return extend$1({
      display: settings.display || 'center',
      cssClass: 'mbsc-alert',
      okText: settings.okText,
      cancelText: settings.cancelText,
      context: settings.context,
      theme: settings.theme,
      closeOnOverlayTap: false,
      onBeforeClose: function onBeforeClose() {
        queue.shift();
      },
      onHide: function onHide(ev, inst) {
        //mobiscroll.activeInstance = active;
        if (resolve) {
          resolve(inst._resolve);
        }

        if (settings.callback) {
          settings.callback(inst._resolve);
        }

        if (inst) {
          inst.destroy();
        } // Show next


        if (popupQueue.length) {
          popupQueue[0].show();
        } else if (notificationQueue.length) {
          // Prevent focus on show for notifications
          notificationQueue[0].show(false, true);
        }
      }
    }, more);
  }

  function getMessage(settings) {
    return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';
  }

  function showAlert(popup, settings, resolve) {
    var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));
    showPopup(inst);
  }

  function showConfirm(popup, settings, resolve) {
    var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
      buttons: ['cancel', 'ok'],
      onSet: function onSet() {
        inst._resolve = true;
      }
    }));
    inst._resolve = false;
    showPopup(inst);
  }

  function showPrompt(popup, settings, resolve) {
    var input, label;
    var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {
      buttons: ['cancel', 'ok'],
      onMarkupReady: function onMarkupReady(event, inst) {
        var s = inst.settings;
        label = inst._markup.find('label');
        label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
        input = inst._markup.find('input')[0];
        setTimeout(function () {
          input.focus();
          input.setSelectionRange(0, input.value.length);
        }, 300);
      },
      onSet: function onSet() {
        inst._resolve = input.value;
      }
    }));
    inst._resolve = null;
    showPopup(inst);
  }

  function showSnackbar(popup, settings, resolve, cssClass, animation) {
    var notificationTimer;
    var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {
      display: settings.display || 'bottom',
      animate: animation,
      cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),
      scrollLock: false,
      focusTrap: false,
      buttons: [],
      onMarkupReady: function onMarkupReady(event, inst) {
        var s = inst.settings;

        var button = inst._markup.find('button');

        button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));
      },
      onShow: function onShow(ev, inst) {
        activeNotification = inst;

        if (settings.duration !== false) {
          notificationTimer = setTimeout(function () {
            if (inst) {
              inst.hide();
            }
          }, settings.duration || 3000);
        }

        if (settings.button) {
          inst.tap($$1('.mbsc-snackbar-btn', ev.target), function () {
            inst.hide();

            if (settings.button.action) {
              settings.button.action.call(this);
            }
          });
        }
      },
      onClose: function onClose() {
        activeNotification = null;
        clearTimeout(notificationTimer);
      }
    }));
    showNotification(inst);
  }

  function showToast(popup, settings, resolve) {
    showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');
  }

  function show(func, popup, settings) {
    var p;

    if (hasPromise) {
      p = new Promise(function (resolve) {
        func(popup, settings, resolve);
      });
    } else {
      func(popup, settings);
    }

    return p;
  }

  mobiscroll.alert = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = getMessage(settings);
    return show(showAlert, popup, settings);
  };

  mobiscroll.confirm = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = getMessage(settings);
    return show(showConfirm, popup, settings);
  };

  mobiscroll.prompt = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = getMessage(settings) + '<label class="mbsc-input">' + (settings.label ? '<span class="mbsc-label">' + settings.label + '</span>' : '') + '<input class="mbsc-control" tabindex="0" type="' + (settings.inputType || 'text') + '" placeholder="' + (settings.placeholder || '') + '" value="' + (settings.value || '') + '">' + '</label>';
    return show(showPrompt, popup, settings);
  };

  mobiscroll.snackbar = function (settings) {
    var popup = document.createElement('div'),
        btn = settings.button;
    popup.innerHTML = '<div class="mbsc-snackbar-cont"><div class="mbsc-snackbar-msg">' + (settings.message || '') + '</div>' + (btn ? '<button class="mbsc-snackbar-btn mbsc-btn mbsc-btn-flat">' + (btn.icon ? '<span class="mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';
    return show(showSnackbar, popup, settings);
  };

  mobiscroll.toast = function (settings) {
    var popup = document.createElement('div');
    popup.innerHTML = '<div class="mbsc-toast-msg">' + (settings.message || '') + '</div>';
    return show(showToast, popup, settings);
  };

  mobiscroll.notification = {
    dismiss: function dismiss() {
      if (activeNotification) {
        activeNotification.hide();
      }
    }
  };

  var halfBorder$1 = os == 'ios' && majorVersion > 7;
  var Form = function Form(el, settings) {
    var s,
        cssClass = '',
        $ctx = $$1(el),
        controls = {},
        that = this;

    function touched() {
      $ctx.removeClass('mbsc-no-touch');
    } // Call the parent constructor


    Base.call(this, el, settings, true);

    that.refresh = function (shallow) {
      if (s.enhance) {
        initControls($ctx, controls, s, shallow);
      }
    };
    /**
     * Form initialization.
     */


    that._init = function () {
      if (!mobiscroll.themes.form[s.theme]) {
        s.theme = 'mobiscroll';
      }

      if (!$ctx.hasClass('mbsc-form')) {
        $ctx.show();
        listen($ctx[0], 'touchstart', touched, {
          passive: true
        });
      }

      if (cssClass) {
        $ctx.removeClass(cssClass);
      } // --- TRIAL SERVER CODE START ---


      cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : ''); // --- TRIAL SERVER CODE END ---

      $ctx.addClass(cssClass).removeClass('mbsc-cloak');
      that.refresh();
    };
    /**
     * Destroys the mobiscroll instance.
     */


    that._destroy = function () {
      $ctx.removeClass(cssClass);
      unlisten($ctx[0], 'touchstart', touched, {
        passive: true
      });

      for (var id in controls) {
        controls[id].destroy();
      }
    };
    /**
     * Object with the underlying form control instances
     * keys are the element id's
     */


    that.controls = controls; // Constructor

    s = that.settings;
    that.init();
  }; // Extend defaults

  Form.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _class: 'form',
    _defaults: {
      tap: hasGhostClick,
      stopProp: true,
      rtl: false,
      enhance: true
    }
  };
  classes.Form = Form; // Init mbsc-form elements on page load

  autoInit('[mbsc-enhance],[mbsc-form]', Form, true);

  // ---

  var Page = function Page(el, settings) {
    var cssClass = '',
        $elm = $$1(el),
        that = this,
        s = that.settings; // Call the parent constructor

    Base.call(this, el, settings, true);
    /**
     * Page initialization.
     */

    that._init = function () {
      var ctx = s.context,
          $ctx = $$1(ctx),
          $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),
          $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),
          css = {};

      if (ctx == 'body') {
        $$1('body,html').addClass('mbsc-page-ctx');
      } else {
        $ctx.addClass('mbsc-page-ctx');
      }

      if (cssClass) {
        $elm.removeClass(cssClass);
      }

      if ($topMenu.length) {
        css.paddingTop = $topMenu[0].offsetHeight;
      }

      if ($bottomMenu.length) {
        css.paddingBottom = $bottomMenu[0].offsetHeight;
      }

      cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
      $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);
    };
    /**
     * Destroys the mobiscroll instance.
     */


    that._destroy = function () {
      $elm.removeClass(cssClass);
    }; // Constructor


    s = that.settings;
    that.init();
  }; // Extend defaults

  Page.prototype = {
    _hasDef: true,
    _hasTheme: true,
    _hasLang: true,
    _class: 'page',
    _defaults: {
      context: 'body'
    }
  };
  classes.Page = Page;
  mobiscroll.themes.page.mobiscroll = {}; // ---
  // Page end
  // Init mbsc-page elements on page load or when mbsc-enhance event is triggeres

  autoInit('[mbsc-page]', Page);

  var MbscPage =
  /*#__PURE__*/
  function (_MbscBase) {
    _inheritsLoose(MbscPage, _MbscBase);

    function MbscPage(props) {
      return _MbscBase.call(this, props) || this;
    }

    var _proto = MbscPage.prototype;

    _proto.componentDidMount = function componentDidMount() {
      // get settings from state
      var settings = this.getSettingsFromProps(this.props); // initialize the mobiscroll

      this.instance = new Page(ReactDOM.findDOMNode(this), settings);
    };

    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var thisOptions = this.getSettingsFromProps(this.props);
      var nextOptions = this.getSettingsFromProps(nextProps); // check if the options or the value changed

      var updateOptions = !deepCompare(thisOptions, nextOptions); // save what should be updated inside mobiscroll

      this.optimizeUpdate = {
        updateOptions: updateOptions
      }; // component should update always, since it's a wrapper component, and it should not block any context

      return true;
    };

    _proto.render = function render() {
      return React.createElement("div", {
        className: this.initialCssClass
      }, this.props.children);
    };

    return MbscPage;
  }(MbscBase);

  MbscPage.propTypes = _extends({}, MbscPage.propTypes, {}, CorePropTypes, {
    onInit: PropTypes.func
  });

  var MbscNote =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(MbscNote, _React$Component);

    function MbscNote(props) {
      return _React$Component.call(this, props) || this;
    }

    var _proto2 = MbscNote.prototype;

    _proto2.render = function render() {
      var className = 'mbsc-note mbsc-note-' + this.props.color;
      return React.createElement("div", {
        className: className
      }, this.props.children);
    };

    return MbscNote;
  }(React.Component);

  _defineProperty(MbscNote, "propTypes", {
    color: PropTypes.string
  });

  _defineProperty(MbscNote, "defaultProps", {
    color: 'primary'
  });

  var MbscAvatar =
  /*#__PURE__*/
  function (_React$Component2) {
    _inheritsLoose(MbscAvatar, _React$Component2);

    function MbscAvatar(props) {
      return _React$Component2.call(this, props) || this;
    }

    var _proto3 = MbscAvatar.prototype;

    _proto3.render = function render() {
      return React.createElement("img", {
        className: "mbsc-avatar",
        src: this.props.src,
        alt: this.props.alt
      });
    };

    return MbscAvatar;
  }(React.Component);

  mobiscroll.Page = MbscPage;
  mobiscroll.Note = MbscNote;
  mobiscroll.Avatar = MbscAvatar;

  var reactNumber = PropTypes.number,
      reactString = PropTypes.string,
      reactFunc = PropTypes.func,
      reactBool = PropTypes.bool;
  /** PropTypes for Form components */

  var StepperPropTypes = {
    onInit: reactFunc,
    onChange: reactFunc,
    value: reactNumber,
    disabled: reactBool,
    min: reactNumber,
    max: reactNumber,
    step: reactNumber,
    val: PropTypes.oneOf(['left', 'right'])
  };
  var SwitchPropTypes = {
    onInit: reactFunc,
    onChange: reactFunc,
    checked: reactBool,
    disabled: reactBool,
    value: reactBool
  };

  var MbscForm =
  /*#__PURE__*/
  function (_MbscOptimized) {
    _inheritsLoose(MbscForm, _MbscOptimized);

    function MbscForm(props) {
      return _MbscOptimized.call(this, props) || this;
    }

    var _proto = MbscForm.prototype;

    _proto.componentDidMount = function componentDidMount() {
      // get settings from state
      var settings = this.getSettingsFromProps(this.props); // initialize the mobiscroll

      this.instance = new Form(ReactDOM.findDOMNode(this), settings);
    };

    _proto.componentDidUpdate = function componentDidUpdate() {
      if (!this.optimizeUpdate.updateOptions && this.optimizeUpdate.updateChildren) {
        this.instance.refresh(true);
      } else if (this.optimizeUpdate.updateOptions) {
        var settings = this.getSettingsFromProps(this.props);
        this.instance.option(settings);
      }
    };

    _proto.checkFormWrapper = function checkFormWrapper(component) {
      if (React.Children.count(component.props.children) == 1) {
        return component.props.children.type == 'form';
      }

      return false;
    };

    _proto.render = function render() {
      // passing through some of the element properties to its children
      var _this$props = this.props,
          action = _this$props.action,
          method = _this$props.method,
          noValidate = _this$props.noValidate,
          renderForm = _this$props.renderForm,
          name = _this$props.name,
          target = _this$props.target,
          autoComplete = _this$props.autoComplete,
          onSubmit = _this$props.onSubmit;

      if (this.checkFormWrapper(this) || !renderForm) {
        return this.props.children;
      } else {
        return React.createElement("form", {
          className: this.initialCssClass,
          action: action,
          name: name,
          target: target,
          method: method,
          autoComplete: autoComplete,
          noValidate: noValidate,
          onSubmit: onSubmit
        }, this.props.children);
      }
    };

    return MbscForm;
  }(MbscOptimized);

  _defineProperty(MbscForm, "defaultProps", {
    renderForm: true
  });

  _defineProperty(MbscForm, "propTypes", _extends({}, CorePropTypes, {
    enhance: reactBool,
    labelStyle: reactString,
    inputStyle: reactString,
    onInit: reactFunc
  }));

  mobiscroll.Form = MbscForm;

  var MbscLabel =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(MbscLabel, _React$Component);

    function MbscLabel(props) {
      return _React$Component.call(this, props) || this;
    }

    var _proto2 = MbscLabel.prototype;

    _proto2.componentDidMount = function componentDidMount() {
      updateCssClasses.call(this, '', this.getClasses(this.props));
    };

    _proto2.componentDidUpdate = function componentDidUpdate() {
      if (this.cssClassUpdate) {
        updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
      }
    };

    _proto2.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var nextClasses = this.getClasses(nextProps);
      var thisClasses = this.getClasses(this.props);

      if (thisClasses !== nextClasses) {
        this.cssClassUpdate = {
          prev: thisClasses,
          next: nextClasses
        };
      } else {
        this.cssClassUpdate = null;
      }

      var update = !deepCompare(this.props, nextProps);
      return update;
    };

    _proto2.getClasses = function getClasses(props) {
      /* eslint-disable no-unused-vars */
      // justification: variable 'valid' and 'className' is declared due to object decomposition
      var valid = props.valid,
          className = props.className,
          color = props.color,
          presetName = props.presetName,
          inputStyle = props.inputStyle,
          labelStyle = props.labelStyle;
      /* eslint-enable */

      var cssClasses = [];

      if (color) {
        cssClasses.push('mbsc-' + presetName + '-' + color);
      }

      if (className) {
        cssClasses.push(className);
      }

      if (inputStyle) {
        cssClasses.push('mbsc-input-' + inputStyle);
      }

      if (labelStyle) {
        cssClasses.push('mbsc-label-' + labelStyle);
      }

      if (valid !== undefined && !valid) {
        cssClasses.push('mbsc-err');
      }

      var cssClass = '';

      if (cssClasses.length) {
        cssClass = cssClasses.reduce(function (pv, cv) {
          return pv + ' ' + cv;
        }).replace(/\s+/g, ' ').trim();
      }

      return cssClass;
    };

    _proto2.render = function render() {
      /* eslint-disable no-unused-vars */
      // justification: variable 'valid' and 'className' is declared due to object decomposition
      var _this$props2 = this.props,
          valid = _this$props2.valid,
          className = _this$props2.className,
          color = _this$props2.color,
          children = _this$props2.children,
          presetName = _this$props2.presetName,
          inputStyle = _this$props2.inputStyle,
          labelStyle = _this$props2.labelStyle,
          other = _objectWithoutPropertiesLoose(_this$props2, ["valid", "className", "color", "children", "presetName", "inputStyle", "labelStyle"]);
      /* eslint-enable */


      return React.createElement("label", other, children);
    };

    return MbscLabel;
  }(React.Component);

  _defineProperty(MbscLabel, "propTypes", {
    valid: PropTypes.bool,
    color: PropTypes.string,
    presetName: PropTypes.string,
    inputStyle: PropTypes.string,
    labelStyle: PropTypes.string
  });

  mobiscroll.Form.Label = MbscLabel; // for backward compatibilty

  mobiscroll.Label = MbscLabel;

  var MbscInput =
  /*#__PURE__*/
  function (_MbscInit) {
    _inheritsLoose(MbscInput, _MbscInit);

    function MbscInput(props) {
      var _this;

      _this = _MbscInit.call(this, props) || this;
      _this.inputMounted = _this.inputMounted.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto3 = MbscInput.prototype;

    _proto3.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new Input(this.inputNode, settings);
    };

    _proto3.inputMounted = function inputMounted(input) {
      this.inputNode = input;
    };

    _proto3.render = function render() {
      /* eslint-disable no-unused-vars */
      var _this$props3 = this.props,
          valid = _this$props3.valid,
          errorMessage = _this$props3.errorMessage,
          type = _this$props3.type,
          icon = _this$props3.icon,
          iconAlign = _this$props3.iconAlign,
          passwordToggle = _this$props3.passwordToggle,
          iconShow = _this$props3.iconShow,
          iconHide = _this$props3.iconHide,
          iconUpload = _this$props3.iconUpload,
          inputStyle = _this$props3.inputStyle,
          labelStyle = _this$props3.labelStyle,
          children = _this$props3.children,
          dropdown = _this$props3.dropdown,
          other = _objectWithoutPropertiesLoose(_this$props3, ["valid", "errorMessage", "type", "icon", "iconAlign", "passwordToggle", "iconShow", "iconHide", "iconUpload", "inputStyle", "labelStyle", "children", "dropdown"]);
      /* eslint-enable */


      var error = null;

      if (errorMessage && !valid) {
        error = React.createElement("span", {
          className: "mbsc-err-msg"
        }, errorMessage);
      }

      var drop = null;

      if (dropdown) {
        drop = React.createElement("span", {
          className: "mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5"
        });
      }

      type = type || 'text';
      return React.createElement(MbscLabel, {
        valid: valid,
        inputStyle: inputStyle,
        labelStyle: labelStyle,
        className: dropdown ? 'mbsc-select' : ''
      }, children, React.createElement("span", {
        className: "mbsc-input-wrap"
      }, React.createElement("input", _extends({
        ref: this.inputMounted,
        type: type,
        "data-icon": icon,
        "data-icon-align": iconAlign,
        "data-password-toggle": passwordToggle,
        "data-icon-show": iconShow,
        "data-icon-hide": iconHide,
        "data-icon-upload": iconUpload
      }, other)), drop, error));
    };

    return MbscInput;
  }(MbscInit);

  _defineProperty(MbscInput, "propTypes", {
    disabled: PropTypes.bool,
    valid: PropTypes.bool,
    errorMessage: PropTypes.string,
    type: PropTypes.string,
    icon: PropTypes.string,
    iconAlign: PropTypes.string,
    passwordToggle: PropTypes.bool,
    iconShow: PropTypes.string,
    iconHide: PropTypes.string,
    iconUpload: PropTypes.string,
    name: PropTypes.string,
    dropdown: PropTypes.bool,
    inputStyle: PropTypes.string,
    labelStyle: PropTypes.string
  });

  mobiscroll.Input = MbscInput;

  var MbscTextArea =
  /*#__PURE__*/
  function (_MbscOptimized2) {
    _inheritsLoose(MbscTextArea, _MbscOptimized2);

    function MbscTextArea(props) {
      var _this2;

      _this2 = _MbscOptimized2.call(this, props) || this;
      _this2.textMounted = _this2.textMounted.bind(_assertThisInitialized(_this2));
      return _this2;
    }

    var _proto4 = MbscTextArea.prototype;

    /**
     * Override
     */
    _proto4.componentDidUpdate = function componentDidUpdate() {
      var settings = this.getSettingsFromProps(this.props);

      if (this.optimizeUpdate) {
        if (this.optimizeUpdate.updateOptions) {
          this.instance.option(settings);
        }

        if (this.optimizeUpdate.updateValue) {
          this.instance.refresh();
        }
      } else {
        this.instance.option(settings);

        if (this.props.value !== undefined) {
          this.instance.refresh();
        }
      }
    };

    _proto4.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new TextArea(this.inputNode, settings);
    };

    _proto4.textMounted = function textMounted(input) {
      this.inputNode = input;
    };

    _proto4.render = function render() {
      /* eslint-disable no-unused-vars */
      var _this$props4 = this.props,
          valid = _this$props4.valid,
          errorMessage = _this$props4.errorMessage,
          icon = _this$props4.icon,
          iconAlign = _this$props4.iconAlign,
          inputStyle = _this$props4.inputStyle,
          labelStyle = _this$props4.labelStyle,
          children = _this$props4.children,
          other = _objectWithoutPropertiesLoose(_this$props4, ["valid", "errorMessage", "icon", "iconAlign", "inputStyle", "labelStyle", "children"]);
      /* eslint-enable */


      var error = null;

      if (errorMessage && !valid) {
        error = React.createElement("span", {
          className: "mbsc-err-msg"
        }, errorMessage);
      }

      return React.createElement(MbscLabel, {
        valid: valid
      }, children, React.createElement("span", {
        className: "mbsc-input-wrap"
      }, React.createElement("textarea", _extends({
        ref: this.textMounted,
        "data-icon": icon,
        "data-icon-align": iconAlign
      }, other)), error));
    };

    return MbscTextArea;
  }(MbscOptimized);

  _defineProperty(MbscTextArea, "propTypes", {
    disabled: PropTypes.bool,
    valid: PropTypes.bool,
    errorMessage: PropTypes.string,
    icon: PropTypes.string,
    iconAlign: PropTypes.string,
    name: PropTypes.string,
    inputStyle: PropTypes.string,
    labelStyle: PropTypes.string
  });

  mobiscroll.Textarea = MbscTextArea;

  var MbscDropdown =
  /*#__PURE__*/
  function (_MbscInit2) {
    _inheritsLoose(MbscDropdown, _MbscInit2);

    function MbscDropdown(props) {
      var _this3;

      _this3 = _MbscInit2.call(this, props) || this;
      _this3.selectMounted = _this3.selectMounted.bind(_assertThisInitialized(_this3));
      return _this3;
    }

    var _proto5 = MbscDropdown.prototype;

    _proto5.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new Select(this.selectNode, settings);
    };

    _proto5.selectMounted = function selectMounted(select) {
      this.selectNode = select;
    };

    _proto5.componentDidUpdate = function componentDidUpdate() {
      this.instance._setText();
    };

    _proto5.render = function render() {
      /* eslint-disable no-unused-vars */
      var _this$props5 = this.props,
          label = _this$props5.label,
          valid = _this$props5.valid,
          errorMessage = _this$props5.errorMessage,
          icon = _this$props5.icon,
          iconAlign = _this$props5.iconAlign,
          inputStyle = _this$props5.inputStyle,
          labelStyle = _this$props5.labelStyle,
          children = _this$props5.children,
          other = _objectWithoutPropertiesLoose(_this$props5, ["label", "valid", "errorMessage", "icon", "iconAlign", "inputStyle", "labelStyle", "children"]);
      /* eslint-enable */


      var error = null;

      if (errorMessage && !valid) {
        error = React.createElement("span", {
          className: "mbsc-err-msg"
        }, errorMessage);
      } else {
        error = React.createElement("span", null);
      }

      return React.createElement(MbscLabel, {
        valid: valid
      }, label, React.createElement("span", {
        className: "mbsc-input-wrap"
      }, React.createElement("select", _extends({
        ref: this.selectMounted,
        "data-icon": icon,
        "data-icon-align": iconAlign
      }, other), children), error));
    };

    return MbscDropdown;
  }(MbscInit);

  _defineProperty(MbscDropdown, "propTypes", {
    label: PropTypes.string,
    disabled: PropTypes.bool,
    valid: PropTypes.bool,
    errorMessage: PropTypes.string,
    icon: PropTypes.string,
    iconAlign: PropTypes.string,
    name: PropTypes.string,
    inputStyle: PropTypes.string,
    labelStyle: PropTypes.string
  });

  mobiscroll.Dropdown = MbscDropdown;

  var MbscButton =
  /*#__PURE__*/
  function (_MbscInit3) {
    _inheritsLoose(MbscButton, _MbscInit3);

    function MbscButton(props) {
      var _this4;

      _this4 = _MbscInit3.call(this, props) || this;
      _this4.btnMounted = _this4.btnMounted.bind(_assertThisInitialized(_this4));
      return _this4;
    }

    var _proto6 = MbscButton.prototype;

    _proto6.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new Button(this.btnNode, settings);
      updateCssClasses.call(this, '', this.getCssClasses(this.props));
    };

    _proto6.componentDidUpdate = function componentDidUpdate() {
      if (this.cssClassUpdate) {
        updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
      }
    };

    _proto6.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var nextClasses = this.getCssClasses(nextProps);
      var thisClasses = this.getCssClasses(this.props);

      if (thisClasses !== nextClasses) {
        this.cssClassUpdate = {
          prev: thisClasses,
          next: nextClasses
        };
      } else {
        this.cssClassUpdate = null;
      }

      return true;
    };

    _proto6.btnMounted = function btnMounted(btn) {
      this.btnNode = btn;
    };

    _proto6.getCssClasses = function getCssClasses(props) {
      var className = props.className,
          color = props.color,
          flat = props.flat,
          block = props.block,
          outline = props.outline;
      var cssClasses = [];

      if (flat) {
        cssClasses.push('mbsc-btn-flat');
      }

      if (block) {
        cssClasses.push('mbsc-btn-block');
      }

      if (outline) {
        cssClasses.push('mbsc-btn-outline');
      }

      if (color) {
        cssClasses.push('mbsc-btn-' + color);
      }

      if (className) {
        cssClasses.push(className);
      }

      var cssClass = '';

      if (cssClasses.length) {
        cssClass = cssClasses.reduce(function (pv, cv) {
          return pv + ' ' + cv;
        }).replace(/\s+/g, ' ').trim();
      }

      return cssClass;
    };

    _proto6.render = function render() {
      /* eslint-disable no-unused-vars */
      // justification: variables 'className', 'color', 'flat', 'block', 'outline' are declared due to object decomposition
      var _this$props6 = this.props,
          type = _this$props6.type,
          children = _this$props6.children,
          className = _this$props6.className,
          color = _this$props6.color,
          flat = _this$props6.flat,
          block = _this$props6.block,
          outline = _this$props6.outline,
          icon = _this$props6.icon,
          other = _objectWithoutPropertiesLoose(_this$props6, ["type", "children", "className", "color", "flat", "block", "outline", "icon"]);
      /* eslint-enable */


      type = type || 'button';
      return React.createElement("button", _extends({
        ref: this.btnMounted,
        type: type,
        "data-icon": icon
      }, other), children);
    };

    return MbscButton;
  }(MbscInit);

  _defineProperty(MbscButton, "propTypes", {
    type: PropTypes.string,
    color: PropTypes.string,
    flat: PropTypes.bool,
    block: PropTypes.bool,
    outline: PropTypes.bool,
    icon: PropTypes.string,
    disabled: PropTypes.bool,
    name: PropTypes.string
  });

  mobiscroll.Button = MbscButton;

  var MbscCheckbox =
  /*#__PURE__*/
  function (_MbscInit4) {
    _inheritsLoose(MbscCheckbox, _MbscInit4);

    function MbscCheckbox(props) {
      var _this5;

      _this5 = _MbscInit4.call(this, props) || this;
      _this5.inputMounted = _this5.inputMounted.bind(_assertThisInitialized(_this5));
      return _this5;
    }

    var _proto7 = MbscCheckbox.prototype;

    _proto7.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new CheckBox(this.inputNode, settings);
    };

    _proto7.inputMounted = function inputMounted(inp) {
      this.inputNode = inp;
    };

    _proto7.render = function render() {
      /* eslint-disable no-unused-vars */
      var _this$props7 = this.props,
          color = _this$props7.color,
          children = _this$props7.children,
          errorMessage = _this$props7.errorMessage,
          inputStyle = _this$props7.inputStyle,
          valid = _this$props7.valid,
          other = _objectWithoutPropertiesLoose(_this$props7, ["color", "children", "errorMessage", "inputStyle", "valid"]);
      /* eslint-enable */


      var error = null;

      if (errorMessage && !valid) {
        error = React.createElement("span", {
          className: "mbsc-err-msg"
        }, errorMessage);
      }

      return React.createElement(MbscLabel, {
        valid: valid,
        color: color,
        presetName: "checkbox"
      }, React.createElement("input", _extends({
        ref: this.inputMounted,
        type: "checkbox"
      }, other)), children, error);
    };

    return MbscCheckbox;
  }(MbscInit);

  _defineProperty(MbscCheckbox, "propTypes", {
    color: PropTypes.string,
    disabled: PropTypes.bool,
    valid: PropTypes.bool,
    errorMessage: PropTypes.string,
    name: PropTypes.string,
    inputStyle: PropTypes.string
  });

  mobiscroll.Checkbox = MbscCheckbox;

  var MbscRadio =
  /*#__PURE__*/
  function (_MbscInit5) {
    _inheritsLoose(MbscRadio, _MbscInit5);

    function MbscRadio(props) {
      var _this6;

      _this6 = _MbscInit5.call(this, props) || this;
      _this6.inputMounted = _this6.inputMounted.bind(_assertThisInitialized(_this6));
      return _this6;
    }

    var _proto8 = MbscRadio.prototype;

    _proto8.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new Radio(this.inputNode, settings);
    };

    _proto8.inputMounted = function inputMounted(inp) {
      this.inputNode = inp;
    };

    _proto8.render = function render() {
      /* eslint-disable no-unused-vars */
      var _this$props8 = this.props,
          color = _this$props8.color,
          children = _this$props8.children,
          inputStyle = _this$props8.inputStyle,
          valid = _this$props8.valid,
          errorMessage = _this$props8.errorMessage,
          other = _objectWithoutPropertiesLoose(_this$props8, ["color", "children", "inputStyle", "valid", "errorMessage"]);
      /* eslint-enable */


      var error = null;

      if (errorMessage && !valid) {
        error = React.createElement("span", {
          className: "mbsc-err-msg"
        }, errorMessage);
      }

      return React.createElement(MbscLabel, {
        valid: valid,
        color: color,
        presetName: "radio"
      }, React.createElement("input", _extends({
        ref: this.inputMounted,
        type: "radio"
      }, other)), children, error);
    };

    return MbscRadio;
  }(MbscInit);

  _defineProperty(MbscRadio, "propTypes", {
    color: PropTypes.string,
    name: PropTypes.string,
    disabled: PropTypes.bool,
    inputStyle: PropTypes.string,
    valid: PropTypes.bool,
    errorMessage: PropTypes.string
  });

  mobiscroll.Radio = MbscRadio;

  var MbscSegmented =
  /*#__PURE__*/
  function (_MbscInit6) {
    _inheritsLoose(MbscSegmented, _MbscInit6);

    function MbscSegmented(props) {
      var _this7;

      _this7 = _MbscInit6.call(this, props) || this;
      _this7.inputMounted = _this7.inputMounted.bind(_assertThisInitialized(_this7));
      return _this7;
    }

    var _proto9 = MbscSegmented.prototype;

    _proto9.componentDidMount = function componentDidMount() {
      var settings = this.getSettingsFromProps(this.props);
      this.instance = new SegmentedItem(this.inputNode, settings);
    };

    _proto9.inputMounted = function inputMounted(inp) {
      this.inputNode = inp;
    };

    _proto9.render = function render() {
      var _this$props9 = this.props,
          color = _this$props9.color,
          children = _this$props9.children,
          multiSelect = _this$props9.multiSelect,
          icon = _this$props9.icon,
          other = _objectWithoutPropertiesLoose(_this$props9, ["color", "children", "multiSelect", "icon"]);

      var type = multiSelect ? 'checkbox' : 'radio';
      return React.createElement(MbscLabel, {
        color: color,
        presetName: "segmented"
      }, React.createElement("input", _extends({
        ref: this.inputMounted,
        type: type,
        "data-icon": icon,
        "data-role": "segmented"
      }, other)), children);
    };

    return MbscSegmented;
  }(MbscInit);

  _defineProperty(MbscSegmented, "propTypes", {
    color: PropTypes.string,
    name: PropTypes.string,
    disabled: PropTypes.bool,
    multiSelect: PropTypes.bool,
    icon: PropTypes.string
  });

  mobiscroll.Segmented = MbscSegmented;

  var MbscFormBase =
  /*#__PURE__*/
  function (_MbscOptimized3) {
    _inheritsLoose(MbscFormBase, _MbscOptimized3);

    function MbscFormBase(props, presetName) {
      var _this8;

      _this8 = _MbscOptimized3.call(this, props) || this;
      _this8.presetName = presetName;
      _this8.inputMounted = _this8.inputMounted.bind(_assertThisInitialized(_this8));
      return _this8;
    }

    var _proto10 = MbscFormBase.prototype;

    _proto10.componentDidMount = function componentDidMount() {
      // get settings from state
      var settings = this.getSettingsFromProps(this.props, this.mbscInit); // initialize the mobiscroll

      this.instance = new classes[this.mbscInit.component || 'Scroller'](this.inputNode, settings); // Add change event listener if handler is passed

      $$1(this.inputNode).on('change', this.props.onChange || function () {}); // sets the initial css classes on the element

      updateCssClasses.call(this, '', this.getCssClasses(this.props));
    };

    _proto10.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var nextClasses = this.getCssClasses(nextProps);
      var thisClasses = this.getCssClasses(this.props);

      if (thisClasses !== nextClasses) {
        this.cssClassUpdate = {
          prev: thisClasses,
          next: nextClasses
        };
      } else {
        this.cssClassUpdate = null;
      }

      return _MbscOptimized3.prototype.shouldComponentUpdate.call(this, nextProps) || this.cssClassUpdate;
    };

    _proto10.componentDidUpdate = function componentDidUpdate() {
      if (this.cssClassUpdate) {
        updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
      }

      if (this.optimizeUpdate.updateOptions) {
        var settings = this.getSettingsFromProps(this.props);
        this.instance.option(settings);
      }
    };

    _proto10.inputMounted = function inputMounted(input) {
      this.inputNode = input;
    };

    _proto10.getCssClasses = function getCssClasses(props) {
      var className = props.className,
          color = props.color,
          cssClasses = [];

      if (color) {
        cssClasses.push('mbsc-' + this.presetName + '-' + color);
      }

      if (className) {
        cssClasses.push(className);
      }

      if (cssClasses.length) {
        return cssClasses.reduce(function (pv, cv) {
          return pv + ' ' + cv;
        }).replace(/\s+/g, ' ').trim();
      } else {
        return '';
      }
    };

    _proto10.render = function render() {
      /* eslint-disable no-unused-vars */
      // justification: variables 'value', 'checked', 'onChange' and 'className' are declared due to object decomposition
      var _this$props10 = this.props,
          className = _this$props10.className,
          children = _this$props10.children,
          value = _this$props10.value,
          valid = _this$props10.valid,
          errorMessage = _this$props10.errorMessage,
          checked = _this$props10.checked,
          onChange = _this$props10.onChange,
          name = _this$props10.name,
          color = _this$props10.color,
          labelStyle = _this$props10.labelStyle,
          inputStyle = _this$props10.inputStyle,
          other = _objectWithoutPropertiesLoose(_this$props10, ["className", "children", "value", "valid", "errorMessage", "checked", "onChange", "name", "color", "labelStyle", "inputStyle"]);
      /* eslint-enable no-unused-vars */


      var error = null;

      if (errorMessage && !valid) {
        error = React.createElement("span", {
          className: "mbsc-err-msg"
        }, errorMessage);
      }

      var type = this.inputType || 'text';
      return React.createElement(MbscLabel, {
        valid: valid,
        inputStyle: inputStyle,
        labelStyle: labelStyle
      }, children, React.createElement("input", _extends({
        ref: this.inputMounted,
        type: type,
        "data-role": name,
        "data-enhance": "false"
      }, other)), error);
    };

    return MbscFormBase;
  }(MbscOptimized);

  _defineProperty(MbscFormBase, "propTypes", _extends({}, CorePropTypes, {
    color: reactString,
    labelStyle: reactString,
    inputStyle: reactString
  }));

  var MbscSwitch =
  /*#__PURE__*/
  function (_MbscFormBase) {
    _inheritsLoose(MbscSwitch, _MbscFormBase);

    function MbscSwitch(props) {
      var _this9;

      _this9 = _MbscFormBase.call(this, props, 'switch') || this;
      _this9.mbscInit = {
        component: 'Switch'
      };
      _this9.inputType = 'checkbox';
      return _this9;
    }

    var _proto11 = MbscSwitch.prototype;

    _proto11.componentDidMount = function componentDidMount() {
      _MbscFormBase.prototype.componentDidMount.call(this);

      if (this.props.checked !== undefined) {
        this.instance.setVal(this.props.checked, true, false);
      }
    };

    _proto11.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var otherChange = _MbscFormBase.prototype.shouldComponentUpdate.call(this, nextProps);

      var checkedChange = this.optimizeUpdate.updateChecked = !deepCompare(nextProps.checked, this.props.checked);
      return otherChange || checkedChange;
    };

    _proto11.componentDidUpdate = function componentDidUpdate() {
      _MbscFormBase.prototype.componentDidUpdate.call(this);

      if (this.optimizeUpdate.updateChecked && !deepCompare(this.instance.getVal(), this.props.checked)) {
        this.instance.setVal(this.props.checked);
      }
    };

    return MbscSwitch;
  }(MbscFormBase);

  MbscSwitch.propTypes = _extends({}, MbscSwitch.propTypes, {}, SwitchPropTypes);
  mobiscroll.Switch = MbscSwitch;

  var MbscStepper =
  /*#__PURE__*/
  function (_MbscFormBase2) {
    _inheritsLoose(MbscStepper, _MbscFormBase2);

    function MbscStepper(props) {
      var _this10;

      _this10 = _MbscFormBase2.call(this, props, 'stepper') || this;
      _this10.mbscInit = {
        component: 'Stepper'
      };
      return _this10;
    }

    var _proto12 = MbscStepper.prototype;

    _proto12.componentDidMount = function componentDidMount() {
      _MbscFormBase2.prototype.componentDidMount.call(this);

      if (this.props.value !== undefined) {
        this.instance.setVal(this.props.value, true, false);
      }
    };

    _proto12.componentDidUpdate = function componentDidUpdate() {
      _MbscFormBase2.prototype.componentDidUpdate.call(this);

      if (this.optimizeUpdate.updateValue && !deepCompare(this.props.value, this.instance.getVal())) {
        this.instance.setVal(this.props.value);
      }
    };

    return MbscStepper;
  }(MbscFormBase);

  MbscStepper.propTypes = _extends({}, MbscStepper.propTypes, {}, StepperPropTypes);
  mobiscroll.Stepper = MbscStepper; // progress

  var MbscColored =
  /*#__PURE__*/
  function (_MbscOptimized4) {
    _inheritsLoose(MbscColored, _MbscOptimized4);

    function MbscColored(props) {
      return _MbscOptimized4.call(this, props) || this;
    }

    var _proto13 = MbscColored.prototype;

    _proto13.componentDidMount = function componentDidMount() {
      updateCssClasses.call(this, '', this.getCssClasses(this.props));
    };

    _proto13.componentDidUpdate = function componentDidUpdate() {
      _MbscOptimized4.prototype.componentDidUpdate.call(this);

      if (this.cssClassUpdate) {
        updateCssClasses.call(this, this.cssClassUpdate.prev, this.cssClassUpdate.next);
      }
    };

    _proto13.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var nextClasses = this.getCssClasses(nextProps);
      var thisClasses = this.getCssClasses(this.props);

      if (thisClasses !== nextClasses) {
        this.cssClassUpdate = {
          prev: thisClasses,
          next: nextClasses
        };
      } else {
        this.cssClassUpdate = null;
      }

      return _MbscOptimized4.prototype.shouldComponentUpdate.call(this, nextProps) || this.cssClassUpdate;
    };

    _proto13.getCssClasses = function getCssClasses(props) {
      var className = props.className,
          color = props.color;
      var cssClasses = [];

      if (color) {
        cssClasses.push('mbsc-' + this.presetName + '-' + color);
      }

      if (className) {
        cssClasses.push(className);
      }

      if (cssClasses.length) {
        return cssClasses.reduce(function (pv, cv) {
          return pv + ' ' + cv;
        }).replace(/\s+/g, ' ').trim();
      } else {
        return '';
      }
    };

    return MbscColored;
  }(MbscOptimized);

  var MbscProgress =
  /*#__PURE__*/
  function (_MbscColored) {
    _inheritsLoose(MbscProgress, _MbscColored);

    function MbscProgress(props) {
      var _this11;

      _this11 = _MbscColored.call(this, props) || this;
      _this11.presetName = 'progress';
      _this11.progressMounted = _this11.progressMounted.bind(_assertThisInitialized(_this11));
      return _this11;
    }

    var _proto14 = MbscProgress.prototype;

    _proto14.componentDidMount = function componentDidMount() {
      // get settings from state
      var settings = this.getSettingsFromProps(this.props); // initialize the mobiscroll

      this.instance = new Progress(this.progressNode, settings);

      if (this.props.value !== undefined) {
        this.instance.setVal(this.props.value, true);
      }

      _MbscColored.prototype.componentDidMount.call(this);
    };

    _proto14.progressMounted = function progressMounted(progress) {
      this.progressNode = progress;
    };

    _proto14.render = function render() {
      /* eslint-disable no-unused-vars */
      // justification: variable 'value' and 'className' is defined due to object decomposotion
      var _this$props11 = this.props,
          className = _this$props11.className,
          children = _this$props11.children,
          value = _this$props11.value,
          color = _this$props11.color,
          inputStyle = _this$props11.inputStyle,
          labelStyle = _this$props11.labelStyle,
          other = _objectWithoutPropertiesLoose(_this$props11, ["className", "children", "value", "color", "inputStyle", "labelStyle"]);
      /* eslint-enable no-unused-vars */


      return React.createElement(MbscLabel, {
        labelStyle: labelStyle,
        inputStyle: inputStyle
      }, children, React.createElement("progress", _extends({
        ref: this.progressMounted
      }, other)));
    };

    return MbscProgress;
  }(MbscColored);

  _defineProperty(MbscProgress, "propTypes", _extends({}, CorePropTypes, {
    "data-icon": reactString,
    "data-icon-align": PropTypes.oneOf(['left', 'right']),
    val: PropTypes.oneOf(['left', 'right']),
    disabled: reactBool,
    max: reactNumber,
    value: reactNumber,
    color: reactString,
    inputStyle: reactString,
    labelStyle: reactString
  }));

  mobiscroll.Progress = MbscProgress; // slider

  var MbscSlider =
  /*#__PURE__*/
  function (_MbscColored2) {
    _inheritsLoose(MbscSlider, _MbscColored2);

    function MbscSlider(props) {
      var _this12;

      _this12 = _MbscColored2.call(this, props) || this;
      _this12.presetName = 'slider';
      _this12.firstInputMounted = _this12.firstInputMounted.bind(_assertThisInitialized(_this12));
      _this12.parentMounted = _this12.parentMounted.bind(_assertThisInitialized(_this12));
      return _this12;
    }

    var _proto15 = MbscSlider.prototype;

    _proto15.componentDidMount = function componentDidMount() {
      // get settings from state
      var settings = this.getSettingsFromProps(this.props); // initialize the mobiscroll

      this.instance = new Slider(this.firstInput, settings);

      if (this.props.value !== undefined) {
        this.instance.setVal(this.props.value, true);
      }

      var that = this; // our own change handler - to receive the change event

      $$1(this.label).on('change', function () {
        if (that.props.onChange) {
          var values = that.instance.getVal();
          that.props.onChange(values);
        }
      });

      _MbscColored2.prototype.componentDidMount.call(this);
    };

    _proto15.firstInputMounted = function firstInputMounted(input) {
      this.firstInput = input;
    };

    _proto15.parentMounted = function parentMounted(label) {
      this.label = ReactDOM.findDOMNode(label);
    };

    _proto15.onValueChanged = function onValueChanged() {// this is not triggered - or the event propagation is stopped somewhere on the line
      // to counter this we attach our own change handler in the `componentDidMount` function
    };

    _proto15.render = function render() {
      /* eslint-disable no-unused-vars */
      // justification: variable 'onChange' and 'className' is defined due to object decomposotion
      var _this$props12 = this.props,
          children = _this$props12.children,
          value = _this$props12.value,
          onChange = _this$props12.onChange,
          className = _this$props12.className,
          icon = _this$props12.icon,
          live = _this$props12.live,
          stepLabels = _this$props12.stepLabels,
          tooltip = _this$props12.tooltip,
          color = _this$props12.color,
          inputStyle = _this$props12.inputStyle,
          labelStyle = _this$props12.labelStyle,
          other = _objectWithoutPropertiesLoose(_this$props12, ["children", "value", "onChange", "className", "icon", "live", "stepLabels", "tooltip", "color", "inputStyle", "labelStyle"]),
          values = value || [];

      live = live || this.props['data-live'] || false;
      icon = icon || this.props['data-icon'];
      /* eslint-enable no-unused-vars */

      if (value !== undefined && !Array.isArray(value)) {
        values = [value];
      }

      return React.createElement(MbscLabel, {
        ref: this.parentMounted,
        labelStyle: labelStyle,
        inputStyle: inputStyle
      }, children, values.map(function (item, index) {
        if (index === 0) {
          return React.createElement("input", _extends({
            ref: this.firstInputMounted,
            "data-label-style": labelStyle,
            "data-input-style": inputStyle,
            "data-icon": icon,
            "data-live": live,
            key: index,
            type: "range"
          }, other));
        }

        return React.createElement("input", {
          key: index,
          type: "range",
          "data-live": live,
          "data-index": index,
          "data-label-style": labelStyle,
          "data-input-style": inputStyle
        });
      }, this));
    };

    return MbscSlider;
  }(MbscColored);

  _defineProperty(MbscSlider, "propTypes", _extends({}, CorePropTypes, {
    highlight: reactBool,
    live: reactBool,
    stepLabels: PropTypes.arrayOf(reactNumber),
    "data-icon": reactString,
    icon: reactString,
    tooltip: reactBool,
    val: PropTypes.oneOf(['left', 'right']),
    disabled: reactBool,
    max: reactNumber,
    min: reactNumber,
    step: reactNumber,
    value: PropTypes.oneOfType([reactNumber, PropTypes.arrayOf(reactNumber)]),
    color: reactString,
    inputStyle: reactString,
    labelStyle: reactString
  }));

  mobiscroll.Slider = MbscSlider;

  var MbscRating =
  /*#__PURE__*/
  function (_MbscColored3) {
    _inheritsLoose(MbscRating, _MbscColored3);

    function MbscRating(props) {
      var _this13;

      _this13 = _MbscColored3.call(this, props) || this;
      _this13.presetName = 'rating';
      _this13.inputMounted = _this13.inputMounted.bind(_assertThisInitialized(_this13));
      _this13.parentMounted = _this13.parentMounted.bind(_assertThisInitialized(_this13));
      return _this13;
    }

    var _proto16 = MbscRating.prototype;

    _proto16.componentDidMount = function componentDidMount() {
      var _this14 = this;

      // get settings from state
      var settings = this.getSettingsFromProps(this.props); // initialize the mobiscroll

      this.instance = new Rating(this.inputNode, settings);

      if (this.props.value !== undefined) {
        this.instance.setVal(this.props.value, true);
      }

      $$1(this.label).on('change', function () {
        if (_this14.props.onChange) {
          var value = _this14.instance.getVal();

          _this14.props.onChange(value);
        }
      });

      _MbscColored3.prototype.componentDidMount.call(this);
    };

    _proto16.inputMounted = function inputMounted(input) {
      this.inputNode = input;
    };

    _proto16.parentMounted = function parentMounted(label) {
      this.label = ReactDOM.findDOMNode(label);
    };

    _proto16.render = function render() {
      /* eslint-disable no-unused-vars */
      // justification: variable 'value' and 'className' is defined due to object decomposotion
      var _this$props13 = this.props,
          className = _this$props13.className,
          children = _this$props13.children,
          onChange = _this$props13.onChange,
          value = _this$props13.value,
          empty = _this$props13.empty,
          filled = _this$props13.filled,
          template = _this$props13.template,
          val = _this$props13.val,
          color = _this$props13.color,
          inputStyle = _this$props13.inputStyle,
          labelStyle = _this$props13.labelStyle,
          other = _objectWithoutPropertiesLoose(_this$props13, ["className", "children", "onChange", "value", "empty", "filled", "template", "val", "color", "inputStyle", "labelStyle"]);
      /* eslint-enable no-unused-vars */


      return React.createElement(MbscLabel, {
        ref: this.parentMounted,
        labelStyle: labelStyle,
        inputStyle: inputStyle
      }, children, React.createElement("input", _extends({
        type: "rating",
        "data-role": "rating",
        "data-val": val,
        "data-template": template,
        "data-empty": empty,
        "data-filled": filled,
        ref: this.inputMounted
      }, other)));
    };

    return MbscRating;
  }(MbscColored);

  _defineProperty(MbscRating, "propTypes", _extends({}, CorePropTypes, {
    val: PropTypes.oneOf(['left', 'right']),
    disabled: reactBool,
    max: reactNumber,
    min: reactNumber,
    step: reactNumber,
    template: reactString,
    empty: reactString,
    filled: reactString,
    value: reactNumber,
    color: reactString,
    inputStyle: reactString,
    labelStyle: reactString
  }));

  mobiscroll.Rating = MbscRating;

  var MbscFormGroup =
  /*#__PURE__*/
  function (_React$Component2) {
    _inheritsLoose(MbscFormGroup, _React$Component2);

    function MbscFormGroup(props) {
      return _React$Component2.call(this, props) || this;
    }

    var _proto17 = MbscFormGroup.prototype;

    _proto17.componentDidMount = function componentDidMount() {
      if (this.props.collapsible !== undefined) {
        var isOpen = this.props.open || false;
        this.instance = new CollapsibleBase(ReactDOM.findDOMNode(this), {
          isOpen: isOpen
        });
      }
    };

    _proto17.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.open !== undefined && this.props.open != prevProps.open) {
        if (this.props.open) {
          this.instance.show();
        } else {
          this.instance.hide();
        }
      }
    };

    _proto17.render = function render() {
      /* eslint-disable no-unused-vars */
      var _this$props14 = this.props,
          children = _this$props14.children,
          inset = _this$props14.inset,
          collapsible = _this$props14.collapsible,
          className = _this$props14.className,
          other = _objectWithoutPropertiesLoose(_this$props14, ["children", "inset", "collapsible", "className"]);

      var cssClasses = "mbsc-form-group" + (inset !== undefined ? '-inset' : '') + " " + (className || '');
      return React.createElement("div", _extends({
        className: cssClasses
      }, other), children);
    };

    return MbscFormGroup;
  }(React.Component);

  _defineProperty(MbscFormGroup, "propTypes", {
    collapsible: PropTypes.bool,
    open: PropTypes.bool,
    inset: PropTypes.any
  });

  mobiscroll.FormGroup = MbscFormGroup;
  mobiscroll.MbscFormGroup = MbscFormGroup; // deprecated

  var MbscFormGroupTitle =
  /*#__PURE__*/
  function (_React$Component3) {
    _inheritsLoose(MbscFormGroupTitle, _React$Component3);

    function MbscFormGroupTitle(props) {
      var _this15;

      _this15 = _React$Component3.call(this, props) || this;
      _this15.cssClasses = "mbsc-form-group-title " + (_this15.props.className || '');
      return _this15;
    }

    var _proto18 = MbscFormGroupTitle.prototype;

    _proto18.render = function render() {
      return React.createElement("div", {
        className: this.cssClasses
      }, this.props.children);
    };

    return MbscFormGroupTitle;
  }(React.Component);

  mobiscroll.FormGroupTitle = MbscFormGroupTitle;
  mobiscroll.MbscFormGroupTitle = MbscFormGroupTitle; // deprecated

  var MbscFormGroupContent =
  /*#__PURE__*/
  function (_React$Component4) {
    _inheritsLoose(MbscFormGroupContent, _React$Component4);

    function MbscFormGroupContent(props) {
      var _this16;

      _this16 = _React$Component4.call(this, props) || this;
      _this16.cssClasses = "mbsc-form-group-content " + (_this16.props.className || '');
      return _this16;
    }

    var _proto19 = MbscFormGroupContent.prototype;

    _proto19.render = function render() {
      return React.createElement("div", {
        className: this.cssClasses
      }, this.props.children);
    };

    return MbscFormGroupContent;
  }(React.Component);

  mobiscroll.FormGroupContent = MbscFormGroupContent;
  mobiscroll.MbscFormGroupContent = MbscFormGroupContent; // deprecated

  var MbscAccordion =
  /*#__PURE__*/
  function (_React$Component5) {
    _inheritsLoose(MbscAccordion, _React$Component5);

    function MbscAccordion(props) {
      var _this17;

      _this17 = _React$Component5.call(this, props) || this;
      _this17.cssClasses = "mbsc-accordion " + (_this17.props.className || '');
      return _this17;
    }

    var _proto20 = MbscAccordion.prototype;

    _proto20.render = function render() {
      return React.createElement("div", {
        className: this.cssClasses
      }, this.props.children);
    };

    return MbscAccordion;
  }(React.Component);

  mobiscroll.Accordion = MbscAccordion;

  // Arabic
  mobiscroll.i18n.ar = {
    // Core
    rtl: true,
    // Right to left mode
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    amText: '',
    pmText: '',
    timeFormat: 'hh:ii A',
    yearText: '',
    nowText: '',
    // Calendar component
    firstDay: 0,
    dateText: '',
    timeText: '',
    closeText: '',
    todayText: '',
    prevMonthText: ' ',
    nextMonthText: ' ',
    prevYearText: ' ',
    nextYearText: ' ',
    allDayText: ' ',
    noEventsText: '  ',
    // Event calendar
    eventText: '',
    eventsText: '',
    moreEventsText: ' ',
    moreEventsPluralText: '  {count}',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Numpad date
    delimiter: '/',
    // Numpad decimal
    decimalSeparator: '.',
    thousandsSeparator: ',',
    // Timer / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: ' ',
    lapText: '',
    hideText: '',
    // Forms
    offText: '',
    onText: '',
    // Listview
    backText: '',
    undoText: ''
  };

  // Bulgarian
  mobiscroll.i18n.bg = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '.',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'H:ii',
    yearText: '',
    nowText: '',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: '',
    timeText: '',
    todayText: '',
    prevMonthText: ' ',
    nextMonthText: ' ',
    prevYearText: ' ',
    nextYearText: ' ',
    closeText: '',
    eventText: '',
    eventsText: '',
    allDayText: ' ',
    noEventsText: ' ',
    moreEventsText: ' {count}',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: '',
    onText: '',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Catal
  mobiscroll.i18n.ca = {
    // Core
    setText: 'Acceptar',
    cancelText: 'Cancellar',
    clearText: 'Esborrar',
    selectedText: '{count} seleccionat',
    selectedPluralText: '{count} seleccionats',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Diumenge', 'Dilluns', 'Dimarts', 'Dimecres', 'Dijous', 'Divendres', 'Dissabte'],
    dayNamesShort: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
    dayNamesMin: ['Dg', 'Dl', 'Dt', 'Dc', 'Dj', 'Dv', 'Ds'],
    dayText: 'Dia',
    hourText: 'Hores',
    minuteText: 'Minuts',
    monthNames: ['Gener', 'Febrer', 'Mar', 'Abril', 'Maig', 'Juny', 'Juliol', 'Agost', 'Setembre', 'Octubre', 'Novembre', 'Desembre'],
    monthNamesShort: ['Gen', 'Feb', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Oct', 'Nov', 'Des'],
    monthText: 'Mes',
    secText: 'Segons',
    timeFormat: 'HH:ii',
    yearText: 'Any',
    nowText: 'Ara',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Avui',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Temps',
    closeText: 'Tancar',
    allDayText: 'Tot el dia',
    noEventsText: 'Cap esdeveniment',
    eventText: 'Esdeveniments',
    eventsText: 'Esdeveniments',
    moreEventsText: '{count} ms',
    // Daterange component
    fromText: 'Iniciar',
    toText: 'Final',
    // Measurement components
    wholeText: 'Sencer',
    fractionText: 'Fracci',
    unitText: 'Unitat',
    // Time / Timespan component
    labels: ['Anys', 'Mesos', 'Dies', 'Hores', 'Minuts', 'Segons', ''],
    labelsShort: ['Anys', 'Mesos', 'Dies', 'Hrs', 'Mins', 'Secs', ''],
    // Timer component
    startText: 'Iniciar',
    stopText: 'Aturar',
    resetText: 'Reiniciar',
    lapText: 'Volta',
    hideText: 'Amagar',
    // Listview
    backText: 'Enrere',
    undoText: 'Desfs',
    // Form
    offText: 'No',
    onText: 'Si'
  };

  // Cestina
  mobiscroll.i18n.cs = {
    // Core
    setText: 'Zadej',
    cancelText: 'Storno',
    clearText: 'Vymazat',
    selectedText: 'Oznaen: {count}',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Nedle', 'Pondl', 'ter', 'Steda', 'tvrtek', 'Ptek', 'Sobota'],
    dayNamesShort: ['Ne', 'Po', 't', 'St', 't', 'P', 'So'],
    dayNamesMin: ['N', 'P', '', 'S', '', 'P', 'S'],
    dayText: 'Den',
    hourText: 'Hodiny',
    minuteText: 'Minuty',
    monthNames: ['Leden', 'nor', 'Bezen', 'Duben', 'Kvten', 'erven', 'ervenec', 'Srpen', 'Z', 'jen', 'Listopad', 'Prosinec'],
    monthNamesShort: ['Led', 'no', 'Be', 'Dub', 'Kv', 'er', 'vc', 'Spr', 'Z', 'j', 'Lis', 'Pro'],
    monthText: 'Msc',
    secText: 'Sekundy',
    timeFormat: 'HH:ii',
    yearText: 'Rok',
    nowText: 'Te',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Dnes',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'as',
    closeText: 'Zavt',
    allDayText: 'Cel den',
    noEventsText: 'dn udlosti',
    eventText: 'Udlost',
    eventsText: 'Udlosti',
    moreEventsText: '{count} dal',
    // Daterange component
    fromText: 'Zatek',
    toText: 'Konec',
    // Measurement components
    wholeText: 'Cel',
    fractionText: 'st',
    unitText: 'Jednotka',
    // Time / Timespan component
    labels: ['Roky', 'Msce', 'Dny', 'Hodiny', 'Minuty', 'Sekundy', ''],
    labelsShort: ['Rok', 'Ms', 'Dny', 'Hod', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Resetovat',
    lapText: 'Etapa',
    hideText: 'Schovat',
    // Listview
    backText: 'Zpt',
    undoText: 'Zpt',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Dansk
  mobiscroll.i18n.da = {
    // Core
    setText: 'St',
    cancelText: 'Annuller',
    clearText: 'Ryd',
    selectedText: '{count} valgt',
    selectedPluralText: '{count} valgt',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
    dayNamesShort: ['Sn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lr'],
    dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
    dayText: 'Dag',
    hourText: 'Timer',
    minuteText: 'Minutter',
    monthNames: ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Mned',
    secText: 'Sekunder',
    amText: 'am',
    pmText: 'pm',
    timeFormat: 'HH.ii',
    yearText: 'r',
    nowText: 'Nu',
    todayText: 'I dag',
    // Calendar component
    firstDay: 1,
    dateText: 'Dato',
    timeText: 'Tid',
    closeText: 'Luk',
    allDayText: 'Hele dagen',
    noEventsText: 'Ingen begivenheder',
    eventText: 'Begivenheder',
    eventsText: 'Begivenheder',
    moreEventsText: '{count} mere',
    // Daterange component
    fromText: 'Start',
    toText: 'Slut',
    // Measurement components
    wholeText: 'Hele',
    fractionText: 'Dele',
    unitText: 'Enhed',
    // Time / Timespan component
    labels: ['r', 'Mneder', 'Dage', 'Timer', 'Minutter', 'Sekunder', ''],
    labelsShort: ['r', 'Mdr', 'Dg', 'Timer', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Nulstil',
    lapText: 'Omgang',
    hideText: 'Skjul',
    // Forms
    offText: 'Fra',
    onText: 'Til',
    // Listview
    backText: 'Tilbage',
    undoText: 'Fortryd'
  };

  // Deutsch
  mobiscroll.i18n.de = {
    // Core
    setText: 'OK',
    cancelText: 'Abbrechen',
    clearText: 'Lschen',
    selectedText: '{count} ausgewhlt',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
    dayNamesShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
    dayNamesMin: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
    dayText: 'Tag',
    delimiter: '.',
    hourText: 'Stunde',
    minuteText: 'Minuten',
    monthNames: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
    monthNamesShort: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
    monthText: 'Monat',
    secText: 'Sekunden',
    timeFormat: 'HH:ii',
    yearText: 'Jahr',
    nowText: 'Jetzt',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Heute',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Zeit',
    closeText: 'Schlieen',
    allDayText: 'Ganztgig',
    noEventsText: 'Keine Ereignisse',
    eventText: 'Ereignis',
    eventsText: 'Ereignisse',
    moreEventsText: '{count} weiteres Element',
    moreEventsPluralText: '{count} weitere Elemente',
    // Daterange component
    fromText: 'Von',
    toText: 'Bis',
    // Measurement components
    wholeText: 'Ganze Zahl',
    fractionText: 'Bruchzahl',
    unitText: 'Maeinheit',
    // Time / Timespan component
    labels: ['Jahre', 'Monate', 'Tage', 'Stunden', 'Minuten', 'Sekunden', ''],
    labelsShort: ['Jahr.', 'Mon.', 'Tag.', 'Std.', 'Min.', 'Sek.', ''],
    // Timer component
    startText: 'Starten',
    stopText: 'Stoppen',
    resetText: 'Zurcksetzen',
    lapText: 'Lap',
    hideText: 'Ausblenden',
    // Listview
    backText: 'Zurck',
    undoText: 'Rckgngig machen',
    // Form
    offText: 'Aus',
    onText: 'Ein',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Greek
  mobiscroll.i18n.el = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '/',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'H:ii',
    yearText: '',
    nowText: '',
    pmText: '',
    amText: '',
    // Calendar component
    firstDay: 1,
    dateText: '',
    timeText: '',
    todayText: '',
    prevMonthText: ' ',
    nextMonthText: ' ',
    prevYearText: ' ',
    nextYearText: ' ',
    closeText: '',
    eventText: '',
    eventsText: '',
    allDayText: '',
    noEventsText: '  ',
    moreEventsText: '{count} ',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: '',
    onText: '',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // English (UK)
  mobiscroll.i18n['en-GB'] = mobiscroll.i18n['en-UK'] = {
    dateFormat: 'dd/mm/yy',
    timeFormat: 'HH:ii'
  };

  // Espaol
  mobiscroll.i18n.es = {
    // Core
    setText: 'Aceptar',
    cancelText: 'Cancelar',
    clearText: 'Borrar',
    selectedText: '{count} seleccionado',
    selectedPluralText: '{count} seleccionados',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Domingo', 'Lunes', 'Martes', 'Mircoles', 'Jueves', 'Viernes', 'Sbado'],
    dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'S'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    dayText: 'Da',
    hourText: 'Horas',
    minuteText: 'Minutos',
    monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
    monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
    monthText: 'Mes',
    secText: 'Segundos',
    timeFormat: 'HH:ii',
    yearText: 'A&ntilde;o',
    nowText: 'Ahora',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Hoy',
    // Calendar component
    firstDay: 1,
    dateText: 'Fecha',
    timeText: 'Tiempo',
    closeText: 'Cerrar',
    allDayText: 'Todo el da',
    noEventsText: 'No hay eventos',
    eventText: 'Evento',
    eventsText: 'Eventos',
    moreEventsText: '{count} ms',
    // Daterange component
    fromText: 'Iniciar',
    toText: 'Final',
    // Measurement components
    wholeText: 'Entero',
    fractionText: 'Fraccin',
    unitText: 'Unidad',
    // Time / Timespan component
    labels: ['Aos', 'Meses', 'Das', 'Horas', 'Minutos', 'Segundos', ''],
    labelsShort: ['Ao', 'Mes', 'Da', 'Hora', 'Min', 'Seg', ''],
    // Timer component
    startText: 'Iniciar',
    stopText: 'Detngase',
    resetText: 'Reinicializar',
    lapText: 'Lap',
    hideText: 'Esconder',
    // Listview
    backText: 'Atrs',
    undoText: 'Deshacer',
    // Form
    offText: 'No',
    onText: 'S',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // 
  mobiscroll.i18n.fa = {
    // Core
    setText: '',
    cancelText: '',
    clearText: ' ',
    selectedText: '{count} ',
    // Datetime component
    calendarSystem: 'jalali',
    dateFormat: 'yy/mm/dd',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'HH:ii',
    timeWheels: 'iiHH',
    // Need this for correct RTL display
    yearText: '',
    nowText: '',
    amText: '',
    pmText: '',
    todayText: '',
    //getNumber: function (n) {
    //    var i,
    //        nums = ["", "", "", "", "", "", "", "", "", ""],
    //        res = '';
    //    n = n + '';
    //    for (i = 0; i < n.length; i++) {
    //        res += nums[+n[i]];
    //    }
    //    return res;
    //},
    // Calendar component
    firstDay: 6,
    rtl: true,
    dateText: ' ',
    timeText: ' ',
    closeText: '',
    allDayText: ' ',
    noEventsText: ' ',
    eventText: '',
    eventsText: '',
    moreEventsText: '{count}  ',
    // Daterange component
    fromText: ' ',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: ' ',
    lapText: 'Lap',
    hideText: ' ',
    // Listview
    backText: '',
    undoText: ''
  };

  // Suomi
  mobiscroll.i18n.fi = {
    // Core
    setText: 'Aseta',
    cancelText: 'Peruuta',
    clearText: 'Tyhjenn',
    selectedText: '{count} valita',
    // Datetime component
    dateFormat: 'd. MM yy',
    dayNames: ['Sunnuntai', 'Maanantai', 'Tiistai', 'Keskiviiko', 'Torstai', 'Perjantai', 'Lauantai'],
    dayNamesShort: ['Su', 'Ma', 'Ti', 'Ke', 'To', 'Pe', 'La'],
    dayNamesMin: ['S', 'M', 'T', 'K', 'T', 'P', 'L'],
    dayText: 'Piv',
    delimiter: '.',
    hourText: 'Tuntia',
    minuteText: 'Minuutti',
    monthNames: ['Tammikuu', 'Helmikuu', 'Maaliskuu', 'Huhtikuu', 'Toukokuu', 'Keskuu', 'Heinkuu', 'Elokuu', 'Syyskuu', 'Lokakuu', 'Marraskuu', 'Joulukuu'],
    monthNamesShort: ['Tam', 'Hel', 'Maa', 'Huh', 'Tou', 'Kes', 'Hei', 'Elo', 'Syy', 'Lok', 'Mar', 'Jou'],
    monthText: 'Kuukausi',
    secText: 'Sekunda',
    timeFormat: 'H:ii',
    yearText: 'Vuosi',
    nowText: 'Nyt',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Pivys',
    timeText: 'Aika',
    todayText: 'Tnn',
    prevMonthText: 'Edellinen kuukausi',
    nextMonthText: 'Ensi kuussa',
    prevYearText: 'Edellinen vuosi',
    nextYearText: 'Ensi vuosi',
    closeText: 'Sulje',
    eventText: 'Tapahtumia',
    eventsText: 'Tapahtumia',
    allDayText: 'Koko piv',
    noEventsText: 'Ei tapahtumia',
    moreEventsText: '{count} muu',
    moreEventsPluralText: '{count} muuta',
    // Daterange component
    fromText: 'Alkaa',
    toText: 'Pttyy',
    // Measurement components
    wholeText: 'Kokonainen',
    fractionText: 'Murtoluku',
    unitText: 'Yksikk',
    // Time / Timespan component
    labels: ['Vuosi', 'Kuukausi', 'Piv', 'Tunnin', 'Minuutti', 'sekuntia', ''],
    labelsShort: ['Vuo', 'Kuu', 'Pi', 'Tun', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Kynnistys',
    stopText: 'Seis',
    resetText: 'Aseta uudelleen',
    lapText: 'Kierros',
    hideText: 'Vuota',
    // Listview
    backText: 'Edellinen',
    undoText: 'Kumoa',
    // Form
    offText: 'Pois',
    onText: 'Pll',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Franais
  mobiscroll.i18n.fr = {
    // Core
    setText: 'Terminer',
    cancelText: 'Annuler',
    clearText: 'Effacer',
    selectedText: '{count} slectionn',
    selectedPluralText: '{count} slectionns',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
    dayNamesShort: ['Dim.', 'Lun.', 'Mar.', 'Mer.', 'Jeu.', 'Ven.', 'Sam.'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    dayText: 'Jour',
    monthText: 'Mois',
    monthNames: ['Janvier', 'Fvrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Aot', 'Septembre', 'Octobre', 'Novembre', 'Dcembre'],
    monthNamesShort: ['Janv.', 'Fvr.', 'Mars', 'Avril', 'Mai', 'Juin', 'Juil.', 'Aot', 'Sept.', 'Oct.', 'Nov.', 'Dc.'],
    hourText: 'Heures',
    minuteText: 'Minutes',
    secText: 'Secondes',
    timeFormat: 'HH:ii',
    yearText: 'Anne',
    nowText: 'Maintenant',
    pmText: 'pm',
    amText: 'am',
    todayText: "Aujourd'hui",
    // Calendar component
    firstDay: 1,
    dateText: 'Date',
    timeText: 'Heure',
    closeText: 'Fermer',
    allDayText: 'Toute la journe',
    noEventsText: 'Aucun vnement',
    eventText: 'vnement',
    eventsText: 'vnements',
    moreEventsText: '{count} autre',
    moreEventsPluralText: '{count} autres',
    // Daterange component
    fromText: 'Dmarrer',
    toText: 'Fin',
    // Measurement components
    wholeText: 'Entier',
    fractionText: 'Fraction',
    unitText: 'Unit',
    // Time / Timespan component
    labels: ['Ans', 'Mois', 'Jours', 'Heures', 'Minutes', 'Secondes', ''],
    labelsShort: ['Ans', 'Mois', 'Jours', 'Hrs', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Dmarrer',
    stopText: 'Arrter',
    resetText: 'Rinitialiser',
    lapText: 'Lap',
    hideText: 'Cachez',
    // Listview
    backText: 'Retour',
    undoText: 'Annuler',
    // Form
    offText: 'Non',
    onText: 'Oui',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Hebrew
  mobiscroll.i18n.he = {
    // Core
    rtl: true,
    // Right to left mode
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    selectedPluralText: '{count} ',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ["'", "'", "'", "'", "'", "'", "'"],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthText: '',
    secText: '',
    amText: 'am',
    pmText: 'pm',
    timeFormat: 'HH:ii',
    timeWheels: 'iiHH',
    // Need this for correct RTL display
    yearText: '',
    nowText: '',
    // Calendar component
    firstDay: 0,
    dateText: '',
    timeText: '',
    closeText: '',
    todayText: '',
    allDayText: ' ',
    noEventsText: ' ',
    // Event calendar
    eventText: '',
    eventsText: '',
    moreEventsText: '  ',
    moreEventsPluralText: '{count}  ',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Forms
    offText: '',
    onText: '',
    // Listview
    backText: '',
    undoText: ' '
  };

  // Hindi
  mobiscroll.i18n.hi = {
    // Core
    setText: ' ',
    cancelText: ' ',
    clearText: ' ',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '.',
    hourText: '',
    minuteText: '',
    monthNames: [' ', '', '', '', '', '', '', ' ', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'H:ii',
    yearText: '',
    nowText: '',
    pmText: '',
    amText: '',
    // Calendar component
    firstDay: 1,
    dateText: '',
    timeText: '',
    todayText: '',
    prevMonthText: ' ',
    nextMonthText: ' ',
    prevYearText: ' ',
    nextYearText: ' ',
    closeText: '',
    eventText: '',
    eventsText: '',
    allDayText: ' ',
    noEventsText: 'Ei tapahtumia',
    moreEventsText: '{count} ',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: ' ',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    // check
    undoText: ' ',
    // Form
    offText: '',
    onText: '',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Croatian
  mobiscroll.i18n.hr = {
    // Core
    setText: 'Postavi',
    cancelText: 'Izlaz',
    clearText: 'Izbrii',
    selectedText: '{count} odabran',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Nedjelja', 'Ponedjeljak', 'Utorak', 'Srijeda', 'etvrtak', 'Petak', 'Subota'],
    dayNamesShort: ['Ned', 'Pon', 'Uto', 'Sri', 'et', 'Pet', 'Sub'],
    dayNamesMin: ['Ne', 'Po', 'Ut', 'Sr', 'e', 'Pe', 'Su'],
    dayText: 'Dan',
    delimiter: '.',
    hourText: 'Sat',
    minuteText: 'Minuta',
    monthNames: ['Sijeanj', 'Veljaa', 'Oujak', 'Travanj', 'Svibanj', 'Lipanj', 'Srpanj', 'Kolovoz', 'Rujan', 'Listopad', 'Studeni', 'Prosinac'],
    monthNamesShort: ['Sij', 'Velj', 'Ou', 'Tra', 'Svi', 'Lip', 'Srp', 'Kol', 'Ruj', 'Lis', 'Stu', 'Pro'],
    monthText: 'Mjesec',
    secText: 'Sekunda',
    timeFormat: 'H:ii',
    yearText: 'Godina',
    nowText: 'Sada',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Vrijeme',
    todayText: 'Danas',
    prevMonthText: 'Prethodni mjesec',
    nextMonthText: 'Sljedei mjesec',
    prevYearText: 'Prethodni godina',
    nextYearText: 'Slijedee godine',
    closeText: 'Zatvori',
    eventText: 'Dogaaj',
    eventsText: 'dogaaja',
    allDayText: 'Cijeli dan',
    noEventsText: 'Bez dogaaja',
    moreEventsText: 'Jo {count}',
    // Daterange component
    fromText: 'Poinje',
    toText: 'Zavrava',
    // Measurement components
    wholeText: 'Cjelina',
    fractionText: 'Frakcija',
    unitText: 'Jedinica',
    // Time / Timespan component
    labels: ['godina', 'mjesec', 'dan', 'sat', 'minuta', 'sekunda', ''],
    labelsShort: ['god', 'mje', 'dan', 'sat', 'min', 'sec', ''],
    // Timer component
    startText: 'Poetak',
    stopText: 'Prekid',
    resetText: 'Resetiraj',
    lapText: 'Ciklus',
    hideText: 'Sakriti',
    // Listview
    backText: 'Natrag',
    undoText: 'Ponitavanje',
    // Form
    offText: 'Uklj.',
    onText: 'Isklj.',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Magyar
  mobiscroll.i18n.hu = {
    // Core
    setText: 'OK',
    cancelText: 'Mgse',
    clearText: 'Trls',
    selectedText: '{count} kivlasztva',
    // Datetime component
    dateFormat: 'yy.mm.dd.',
    dayNames: ['Vasrnap', 'Htf', 'Kedd', 'Szerda', 'Cstrtk', 'Pntek', 'Szombat'],
    dayNamesShort: ['Va', 'H', 'Ke', 'Sze', 'Cs', 'P', 'Szo'],
    dayNamesMin: ['V', 'H', 'K', 'Sz', 'Cs', 'P', 'Sz'],
    dayText: 'Nap',
    delimiter: '.',
    hourText: 'ra',
    minuteText: 'Perc',
    monthNames: ['Janur', 'Februr', 'Mrcius', 'prilis', 'Mjus', 'Jnius', 'Jlius', 'Augusztus', 'Szeptember', 'Oktber', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mr', 'pr', 'Mj', 'Jn', 'Jl', 'Aug', 'Szep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Hnap',
    secText: 'Msodperc',
    timeFormat: 'H:ii',
    yearText: 'v',
    nowText: 'Most',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: 'Dtum',
    timeText: 'Id',
    todayText: 'Ma',
    prevMonthText: 'Elz hnap',
    nextMonthText: 'Kvetkez hnap',
    prevYearText: 'Elz v',
    nextYearText: 'Kvetkez v',
    closeText: 'Bezr',
    eventText: 'esemny',
    eventsText: 'esemny',
    allDayText: 'Egsz nap',
    noEventsText: 'Nincs esemny',
    moreEventsText: '{count} tovbbi',
    // Daterange component
    fromText: 'Eleje',
    toText: 'Vge',
    // Measurement components
    wholeText: 'Egsz',
    fractionText: 'Trt',
    unitText: 'Egysg',
    // Time / Timespan component
    labels: ['v', 'Hnap', 'Nap', 'ra', 'Perc', 'Msodperc', ''],
    labelsShort: ['v', 'H.', 'Nap', 'ra', 'Perc', 'Mp.', ''],
    // Timer component
    startText: 'Indt',
    stopText: 'Megllt',
    resetText: 'Visszallt',
    lapText: 'Lap',
    hideText: 'Elrejt',
    // Listview
    backText: 'Vissza',
    undoText: 'Visszavon',
    // Form
    offText: 'Ki',
    onText: 'Be',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Italiano 
  mobiscroll.i18n.it = {
    // Core
    setText: 'OK',
    cancelText: 'Annulla',
    clearText: 'Chiarire',
    selectedText: '{count} selezionato',
    selectedPluralText: '{count} selezionati',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Domenica', 'Luned', 'Marted', 'Mercoled', 'Gioved', 'Venerd', 'Sabato'],
    dayNamesShort: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'G', 'V', 'S'],
    dayText: 'Giorno',
    hourText: 'Ore',
    minuteText: 'Minuti',
    monthNames: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
    monthNamesShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
    monthText: 'Mese',
    secText: 'Secondi',
    timeFormat: 'HH:ii',
    yearText: 'Anno',
    nowText: 'Ora',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Oggi',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Volta',
    closeText: 'Chiudere',
    allDayText: 'Tutto il giorno',
    noEventsText: 'Nessun evento',
    eventText: 'Evento',
    eventsText: 'Eventi',
    moreEventsText: '{count} altro',
    moreEventsPluralText: 'altri {count}',
    // Daterange component
    fromText: 'Inizio',
    toText: 'Fine',
    // Measurement components
    wholeText: 'Intero',
    fractionText: 'Frazione',
    unitText: 'Unit',
    // Time / Timespan component
    labels: ['Anni', 'Mesi', 'Giorni', 'Ore', 'Minuti', 'Secondi', ''],
    labelsShort: ['Anni', 'Mesi', 'Gio', 'Ore', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Inizio',
    stopText: 'Arresto',
    resetText: 'Ripristina',
    lapText: 'Lap',
    hideText: 'Nascondi',
    // Listview
    backText: 'Indietro',
    undoText: 'Annulla',
    // Form
    offText: 'Via',
    onText: 'Su',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  //  - Japanese
  mobiscroll.i18n.ja = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'yymmdd',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    hourText: '',
    minuteText: '',
    monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    monthText: '',
    secText: '',
    timeFormat: 'HH:ii',
    yearText: '',
    nowText: '',
    pmText: '',
    amText: '',
    yearSuffix: '',
    monthSuffix: '',
    daySuffix: '',
    todayText: '',
    // Calendar component
    dateText: '',
    timeText: '',
    closeText: '',
    allDayText: '',
    noEventsText: '',
    eventText: '',
    eventsText: '',
    moreEventsText: ' {count} ',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    undoText: ''
  };

  // Korean
  mobiscroll.i18n.ko = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'yymmdd',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '-',
    hourText: '',
    minuteText: '',
    monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    monthNamesShort: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    monthText: '',
    secText: '',
    timeFormat: 'H:ii',
    yearText: '',
    nowText: '',
    pmText: '',
    amText: '',
    yearSuffix: '',
    monthSuffix: '',
    daySuffix: '',
    // Calendar component
    firstDay: 0,
    dateText: '',
    timeText: '',
    todayText: '',
    prevMonthText: ' ',
    nextMonthText: ' ',
    prevYearText: ' ',
    nextYearText: ' ',
    closeText: '',
    eventText: '',
    eventsText: '',
    allDayText: '',
    noEventsText: ' ',
    moreEventsText: '{count} ',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: ' ',
    resetText: '',
    lapText: '',
    hideText: ' ',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: '',
    onText: '',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Lietuvi
  mobiscroll.i18n.lt = {
    // Core
    setText: 'OK',
    cancelText: 'Ataukti',
    clearText: 'Ivalyti',
    selectedText: 'Pasirinktas {count}',
    selectedPluralText: 'Pasirinkti {count}',
    // Datetime component
    dateFormat: 'yy-mm-dd',
    dayNames: ['Sekmadienis', 'Pirmadienis', 'Antradienis', 'Treiadienis', 'Ketvirtadienis', 'Penktadienis', 'etadienis'],
    dayNamesShort: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
    dayNamesMin: ['S', 'Pr', 'A', 'T', 'K', 'Pn', ''],
    dayText: 'Diena',
    hourText: 'Valanda',
    minuteText: 'Minutes',
    monthNames: ['Sausis', 'Vasaris', 'Kovas', 'Balandis', 'Gegu', 'Birelis', 'Liepa', 'Rugpjtis', 'Rugsjis', 'Spalis', 'Lapkritis', 'Gruodis'],
    monthNamesShort: ['Sau', 'Vas', 'Kov', 'Bal', 'Geg', 'Bir', 'Lie', 'Rugp', 'Rugs', 'Spa', 'Lap', 'Gruo'],
    monthText: 'Mnuo',
    secText: 'Sekundes',
    amText: 'am',
    pmText: 'pm',
    timeFormat: 'HH:ii',
    yearText: 'Metai',
    nowText: 'Dabar',
    todayText: 'iandien',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Laikas',
    closeText: 'Udaryti',
    allDayText: 'Vis dien',
    noEventsText: 'Nra vyki',
    eventText: 'vyki',
    eventsText: 'vykiai',
    moreEventsText: 'Dar {count}',
    // Daterange component
    fromText: 'Nuo',
    toText: 'Iki',
    // Measurement components
    wholeText: 'Visas',
    fractionText: 'Frakcija',
    unitText: 'Vienetas',
    // Time / Timespan component
    labels: ['Metai', 'Mnesiai', 'Dienos', 'Valandos', 'Minutes', 'Sekundes', ''],
    labelsShort: ['m', 'mn.', 'd', 'h', 'min', 's', ''],
    // Timer component
    startText: 'Pradti',
    stopText: 'Sustabdyti',
    resetText: 'Inaujo',
    lapText: 'Ratas',
    hideText: 'Slpti',
    // Listview
    backText: 'Atgal',
    undoText: 'Anuliuoti',
    // Form
    offText: 'Ij.',
    onText: 'j.',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Nederlands
  mobiscroll.i18n.nl = {
    // Core
    setText: 'Instellen',
    cancelText: 'Annuleren',
    clearText: 'Leegmaken',
    selectedText: '{count} gekozen',
    // Datetime component
    dateFormat: 'dd-mm-yy',
    dayNames: ['Zondag', 'Maandag', 'Dinsdag', 'Woensdag', 'Donderdag', 'Vrijdag', 'Zaterdag'],
    dayNamesShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
    dayNamesMin: ['z', 'm', 'd', 'w', 'd', 'v', 'z'],
    dayText: 'Dag',
    hourText: 'Uur',
    minuteText: 'Minuten',
    monthNames: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
    monthNamesShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
    monthText: 'Maand',
    secText: 'Seconden',
    timeFormat: 'HH:ii',
    yearText: 'Jaar',
    nowText: 'Nu',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Vandaag',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Tijd',
    closeText: 'Sluiten',
    allDayText: 'Hele dag',
    noEventsText: 'Geen activiteiten',
    eventText: 'Activiteit',
    eventsText: 'Activiteiten',
    moreEventsText: 'nog {count}',
    // Daterange component
    fromText: 'Start',
    toText: 'Einde',
    // Measurement components
    wholeText: 'geheel',
    fractionText: 'fractie',
    unitText: 'eenheid',
    // Time / Timespan component
    labels: ['Jaren', 'Maanden', 'Dagen', 'Uren', 'Minuten', 'Seconden', ''],
    labelsShort: ['j', 'm', 'd', 'u', 'min', 'sec', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Reset',
    lapText: 'Ronde',
    hideText: 'Verbergen',
    // Listview
    backText: 'Terug',
    undoText: 'Onged. maken',
    // Form
    offText: 'Uit',
    onText: 'Aan',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Norsk
  mobiscroll.i18n.no = {
    // Core
    setText: 'OK',
    cancelText: 'Avbryt',
    clearText: 'Tmme',
    selectedText: '{count} valgt',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Sndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
    dayNamesShort: ['S', 'Ma', 'Ti', 'On', 'To', 'Fr', 'L'],
    dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
    dayText: 'Dag',
    delimiter: '.',
    hourText: 'Time',
    minuteText: 'Minutt',
    monthNames: ['Januar', 'Februar', 'Mars', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Desember'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Des'],
    monthText: 'Mned',
    secText: 'Sekund',
    timeFormat: 'HH:ii',
    yearText: 'r',
    nowText: 'N',
    pmText: 'pm',
    amText: 'am',
    todayText: 'I dag',
    // Calendar component
    firstDay: 1,
    dateText: 'Dato',
    timeText: 'Tid',
    closeText: 'Lukk',
    allDayText: 'Hele dagen',
    noEventsText: 'Ingen hendelser',
    eventText: 'Hendelse',
    eventsText: 'Hendelser',
    moreEventsText: '{count} mere',
    // Daterange component
    fromText: 'Start',
    toText: 'End',
    // Measurement components
    wholeText: 'Hele',
    fractionText: 'Fraksjon',
    unitText: 'Enhet',
    // Time / Timespan component
    labels: ['r', 'Mneder', 'Dager', 'Timer', 'Minutter', 'Sekunder', ''],
    labelsShort: ['r', 'Mn', 'Dag', 'Time', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stopp',
    resetText: 'Tilbakestille',
    lapText: 'Runde',
    hideText: 'Skjul',
    // Listview
    backText: 'Tilbake',
    undoText: 'Angre',
    // Form
    offText: 'Av',
    onText: 'P',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Polski
  mobiscroll.i18n.pl = {
    // Core
    setText: 'Zestaw',
    cancelText: 'Anuluj',
    clearText: 'Oczyci',
    selectedText: 'Wybr: {count}',
    // Datetime component
    dateFormat: 'yy-mm-dd',
    dayNames: ['Niedziela', 'Poniedziaek', 'Wtorek', 'roda', 'Czwartek', 'Pitek', 'Sobota'],
    dayNamesShort: ['Niedz.', 'Pon.', 'Wt.', 'r.', 'Czw.', 'Pt.', 'Sob.'],
    dayNamesMin: ['N', 'P', 'W', '', 'C', 'P', 'S'],
    dayText: 'Dzie',
    hourText: 'Godziny',
    minuteText: 'Minuty',
    monthNames: ['Stycze', 'Luty', 'Marzec', 'Kwiecie', 'Maj', 'Czerwiec', 'Lipiec', 'Sierpie', 'Wrzesie', 'Padziernik', 'Listopad', 'Grudzie'],
    monthNamesShort: ['Sty', 'Lut', 'Mar', 'Kwi', 'Maj', 'Cze', 'Lip', 'Sie', 'Wrz', 'Pa', 'Lis', 'Gru'],
    monthText: 'Miesic',
    secText: 'Sekundy',
    timeFormat: 'HH:ii',
    yearText: 'Rok',
    nowText: 'Teraz',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Dzisiaj',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Czas',
    closeText: 'Zakoczenie',
    allDayText: 'Cay dzie',
    noEventsText: 'Brak wydarze',
    eventText: 'Wydarze',
    eventsText: 'Wydarzenia',
    moreEventsText: 'Jeszcze {count}',
    // Daterange component
    fromText: 'Rozpoczcie',
    toText: 'Koniec',
    // Measurement components
    wholeText: 'Cay',
    fractionText: 'Uamek',
    unitText: 'Jednostka',
    // Time / Timespan component
    labels: ['Lata', 'Miesic', 'Dni', 'Godziny', 'Minuty', 'Sekundy', ''],
    labelsShort: ['R', 'M', 'Dz', 'Godz', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Rozpoczcie',
    stopText: 'Zatrzyma',
    resetText: 'Zresetowa',
    lapText: 'Zakadka',
    hideText: 'Ukry',
    // Listview
    backText: 'Wr',
    undoText: 'Cofnij',
    // Form
    offText: 'Wy',
    onText: 'W',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Portugus Brasileiro
  mobiscroll.i18n['pt-BR'] = {
    // Core
    setText: 'Selecionar',
    cancelText: 'Cancelar',
    clearText: 'Claro',
    selectedText: '{count} selecionado',
    selectedPluralText: '{count} selecionados',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
    dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
    dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
    dayText: 'Dia',
    hourText: 'Hora',
    minuteText: 'Minutos',
    monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    monthText: 'Ms',
    secText: 'Segundo',
    timeFormat: 'HH:ii',
    yearText: 'Ano',
    nowText: 'Agora',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Hoje',
    // Calendar component
    dateText: 'Data',
    timeText: 'Tempo',
    closeText: 'Fechar',
    allDayText: 'Dia inteiro',
    noEventsText: 'Nenhum evento',
    eventText: 'Evento',
    eventsText: 'Eventos',
    moreEventsText: 'Mais {count}',
    // Daterange component
    fromText: 'In&iacute;cio',
    toText: 'Fim',
    // Measurement components
    wholeText: 'Inteiro',
    fractionText: 'Frao',
    unitText: 'Unidade',
    // Time / Timespan component
    labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
    labelsShort: ['Ano', 'M&ecirc;s', 'Dia', 'Hora', 'Min', 'Seg', ''],
    // Timer component
    startText: 'Comear',
    stopText: 'Pare',
    resetText: 'Reinicializar',
    lapText: 'Lap',
    hideText: 'Esconder',
    // Listview
    backText: 'Anterior',
    undoText: 'Desfazer',
    // Form
    offText: 'Desl',
    onText: 'Lig',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Portugus Europeu
  mobiscroll.i18n['pt-PT'] = {
    // Core
    setText: 'Seleccionar',
    cancelText: 'Cancelar',
    clearText: 'Claro',
    selectedText: '{count} selecionado',
    selectedPluralText: '{count} selecionados',
    // Datetime component
    dateFormat: 'dd-mm-yy',
    dayNames: ['Domingo', 'Segunda-feira', 'Tera-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sbado'],
    dayNamesShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
    dayNamesMin: ['D', 'S', 'T', 'Q', 'Q', 'S', 'S'],
    dayText: 'Dia',
    hourText: 'Horas',
    minuteText: 'Minutos',
    monthNames: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthNamesShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    monthText: 'Ms',
    secText: 'Segundo',
    timeFormat: 'HH:ii',
    yearText: 'Ano',
    nowText: 'Actualizar',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Hoy',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Tempo',
    closeText: 'Fechar',
    allDayText: 'Todo o dia',
    noEventsText: 'Nenhum evento',
    eventText: 'Evento',
    eventsText: 'Eventos',
    moreEventsText: 'mais {count}',
    // Daterange component
    fromText: 'Incio',
    toText: 'Fim',
    // Measurement components
    wholeText: 'Inteiro',
    fractionText: 'Fraco',
    unitText: 'Unidade',
    // Time / Timespan component
    labels: ['Anos', 'Meses', 'Dias', 'Horas', 'Minutos', 'Segundos', ''],
    labelsShort: ['Ano', 'Ms', 'Dia', 'Hora', 'Min', 'Seg', ''],
    // Timer component
    startText: 'Comear',
    stopText: 'Parar',
    resetText: 'Reinicializar',
    lapText: 'Lap',
    hideText: 'Esconder',
    // Listview
    backText: 'Anterior',
    undoText: 'Anular',
    // Form
    offText: 'Desl',
    onText: 'Lig',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Romn
  mobiscroll.i18n.ro = {
    // Core
    setText: 'Setare',
    cancelText: 'Anulare',
    clearText: 'tergere',
    selectedText: '{count} selectat',
    selectedPluralText: '{count} selectate',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Duminic', 'Luni', 'Mari', 'Miercuri', 'Joi', 'Vineri', 'Smbt'],
    dayNamesShort: ['Du', 'Lu', 'Ma', 'Mi', 'Jo', 'Vi', 'S'],
    dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
    dayText: ' Ziua',
    delimiter: '.',
    hourText: ' Ore ',
    minuteText: 'Minute',
    monthNames: ['Ianuarie', 'Februarie', 'Martie', 'Aprilie', 'Mai', 'Iunie', 'Iulie', 'August', 'Septembrie', 'Octombrie', 'Noiembrie', 'Decembrie'],
    monthNamesShort: ['Ian.', 'Feb.', 'Mar.', 'Apr.', 'Mai', 'Iun.', 'Iul.', 'Aug.', 'Sept.', 'Oct.', 'Nov.', 'Dec.'],
    monthText: 'Luna',
    secText: 'Secunde',
    timeFormat: 'HH:ii',
    yearText: 'Anul',
    nowText: 'Acum',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Astzi',
    prevMonthText: 'Luna anterioar',
    nextMonthText: 'Luna urmtoare',
    prevYearText: 'Anul anterior',
    nextYearText: 'Anul urmtor',
    eventText: 'Eveniment',
    eventsText: 'Evenimente',
    allDayText: 'Toat ziua',
    noEventsText: 'Niciun eveniment',
    moreEventsText: 'nc unul',
    moreEventsPluralText: 'nc {count}',
    // Calendar component
    firstDay: 1,
    dateText: 'Data',
    timeText: 'Ora',
    closeText: 'nchidere',
    // Daterange component
    fromText: 'Start',
    toText: 'Final',
    // Measurement components
    wholeText: 'Complet',
    fractionText: 'Parial',
    unitText: 'Unitate',
    // Time / Timespan component
    labels: ['Ani', 'Luni', 'Zile', 'Ore', 'Minute', 'Secunde', ''],
    labelsShort: ['Ani', 'Luni', 'Zile', 'Ore', 'Min.', 'Sec.', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Resetare',
    lapText: 'Tur',
    hideText: 'Ascundere',
    // Listview
    backText: 'napoi',
    undoText: 'Anuleaz',
    // Form
    offText: 'Nu',
    onText: 'Da',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  //  (UA)
  mobiscroll.i18n['ru-UA'] = {
    // Core
    setText: '',
    cancelText: '',
    clearText: 'r',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '.',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['.', '.', '', '.', '', '', '', '.', '.', '.', '.', '.'],
    monthText: '',
    secText: '',
    timeFormat: 'HH:ii',
    yearText: '',
    nowText: '',
    amText: 'am',
    pmText: 'pm',
    todayText: 'C',
    // Calendar component
    firstDay: 1,
    dateText: '',
    timeText: '',
    closeText: '',
    allDayText: ' ',
    noEventsText: ' ',
    eventText: '',
    eventsText: '',
    moreEventsText: ' {count}',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '  ', '  ', '  ', '  ', ' ', ''],
    labelsShort: ['', '.', '.', '.', '.', '.', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '  ',
    lapText: '  ',
    hideText: '  ',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // 
  mobiscroll.i18n['ru-RU'] = mobiscroll.i18n.ru = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '.',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'HH:ii',
    yearText: '',
    nowText: '',
    amText: 'am',
    pmText: 'pm',
    todayText: 'C',
    // Calendar component
    firstDay: 1,
    dateText: '',
    timeText: '',
    closeText: '',
    allDayText: ' ',
    noEventsText: ' ',
    eventText: '',
    eventsText: '',
    moreEventsText: ' {count}',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Slovencina
  mobiscroll.i18n.sk = {
    // Core
    setText: 'Zadaj',
    cancelText: 'Zrui',
    clearText: 'Vymaza',
    selectedText: 'Oznaen: {count}',
    // Datetime component
    dateFormat: 'd.m.yy',
    dayNames: ['Nedea', 'Pondelok', 'Utorok', 'Streda', 'tvrtok', 'Piatok', 'Sobota'],
    dayNamesShort: ['Ne', 'Po', 'Ut', 'St', 't', 'Pi', 'So'],
    dayNamesMin: ['N', 'P', 'U', 'S', '', 'P', 'S'],
    dayText: 'e',
    hourText: 'Hodiny',
    minuteText: 'Minty',
    monthNames: ['Janur', 'Februr', 'Marec', 'Aprl', 'Mj', 'Jn', 'Jl', 'August', 'September', 'Oktber', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mj', 'Jn', 'Jl', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Mesiac',
    secText: 'Sekundy',
    timeFormat: 'H:ii',
    yearText: 'Rok',
    nowText: 'Teraz',
    amText: 'am',
    pmText: 'pm',
    todayText: 'Dnes',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'as',
    closeText: 'Zavrie',
    allDayText: 'Cel de',
    noEventsText: 'iadne udalosti',
    eventText: 'Udalost',
    eventsText: 'Udalosti',
    moreEventsText: '{count} alia',
    moreEventsPluralText: '{count} alie',
    // Daterange component
    fromText: 'Zaiatok',
    toText: 'Koniec',
    // Measurement components
    wholeText: 'Cel',
    fractionText: 'as',
    unitText: 'Jednotka',
    // Time / Timespan component
    labels: ['Roky', 'Mesiace', 'Dni', 'Hodiny', 'Minty', 'Sekundy', ''],
    labelsShort: ['Rok', 'Mes', 'Dni', 'Hod', 'Min', 'Sec', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stop',
    resetText: 'Resetova',
    lapText: 'Etapa',
    hideText: 'Schova',
    // Listview
    backText: 'Sp',
    undoText: 'Sp',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Serbian
  mobiscroll.i18n.sr = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    delimiter: '.',
    hourText: '',
    minuteText: '',
    monthNames: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'H:ii',
    yearText: '',
    nowText: '',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 1,
    dateText: '',
    timeText: '',
    todayText: '',
    prevMonthText: ' ',
    nextMonthText: ' ',
    prevYearText: ' ',
    nextYearText: ' ',
    closeText: '',
    eventText: '',
    eventsText: '',
    allDayText: ' ',
    noEventsText: ' ',
    moreEventsText: ' {count}',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: 'e',
    onText: '',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Svenska
  mobiscroll.i18n.sv = {
    // Core
    setText: 'OK',
    cancelText: 'Avbryt',
    clearText: 'Klara',
    selectedText: '{count} vald',
    // Datetime component
    dateFormat: 'yy-mm-dd',
    dayNames: ['Sndag', 'Mndag', 'Tisdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lrdag'],
    dayNamesShort: ['S', 'M', 'Ti', 'On', 'To', 'Fr', 'L'],
    dayNamesMin: ['S', 'M', 'T', 'O', 'T', 'F', 'L'],
    dayText: 'Dag',
    hourText: 'Timme',
    minuteText: 'Minut',
    monthNames: ['Januari', 'Februari', 'Mars', 'April', 'Maj', 'Juni', 'Juli', 'Augusti', 'September', 'Oktober', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec'],
    monthText: 'Mnad',
    secText: 'Sekund',
    timeFormat: 'HH:ii',
    yearText: 'r',
    nowText: 'Nu',
    pmText: 'pm',
    amText: 'am',
    todayText: 'I dag',
    // Calendar component
    firstDay: 1,
    dateText: 'Datum',
    timeText: 'Tid',
    closeText: 'Stng',
    allDayText: 'Heldag',
    noEventsText: 'Inga aktiviteter',
    eventText: 'Hndelse',
    eventsText: 'Hndelser',
    moreEventsText: '{count} till',
    // Daterange component
    fromText: 'Start',
    toText: 'Slut',
    // Measurement components
    wholeText: 'Hela',
    fractionText: 'Brk',
    unitText: 'Enhet',
    // Time / Timespan component
    labels: ['r', 'Mnader', 'Dagar', 'Timmar', 'Minuter', 'Sekunder', ''],
    labelsShort: ['r', 'Mn', 'Dag', 'Tim', 'Min', 'Sek', ''],
    // Timer component
    startText: 'Start',
    stopText: 'Stopp',
    resetText: 'terstll',
    lapText: 'Varv',
    hideText: 'Dlj',
    // Listview
    backText: 'Tillbaka',
    undoText: 'ngra',
    // Form
    offText: 'Av',
    onText: 'P'
  };

  // Trke
  mobiscroll.i18n.tr = {
    // Core
    setText: 'Se',
    cancelText: 'ptal',
    clearText: 'Temizleyin',
    selectedText: '{count} seilmi',
    // Datetime component
    dateFormat: 'dd.mm.yy',
    dayNames: ['Pazar', 'Pazartesi', 'Sal', 'aramba', 'Perembe', 'Cuma', 'Cumartesi'],
    dayNamesShort: ['Paz', 'Pzt', 'Sal', 'ar', 'Per', 'Cum', 'Cmt'],
    dayNamesMin: ['P', 'P', 'S', '', 'P', 'C', 'C'],
    dayText: 'Gn',
    delimiter: '.',
    hourText: 'Saat',
    minuteText: 'Dakika',
    monthNames: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],
    monthNamesShort: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],
    monthText: 'Ay',
    secText: 'Saniye',
    timeFormat: 'HH:ii',
    yearText: 'Yl',
    nowText: 'imdi',
    pmText: 'pm',
    amText: 'am',
    todayText: 'Bugn',
    // Calendar component
    firstDay: 1,
    dateText: 'Tarih',
    timeText: 'Zaman',
    closeText: 'Kapatmak',
    allDayText: 'Tm gn',
    noEventsText: 'Etkinlik Yok',
    eventText: 'Etkinlik',
    eventsText: 'Etkinlikler',
    moreEventsText: '{count} tane daha',
    // Daterange component
    fromText: 'Bala',
    toText: 'Son',
    // Measurement components
    wholeText: 'Tam',
    fractionText: 'Kesir',
    unitText: 'Birim',
    // Time / Timespan component
    labels: ['Yl', 'Ay', 'Gn', 'Saat', 'Dakika', 'Saniye', ''],
    labelsShort: ['Yl', 'Ay', 'Gn', 'Sa', 'Dak', 'Sn', ''],
    // Timer component
    startText: 'Bala',
    stopText: 'Durdur',
    resetText: 'Sfrla',
    lapText: 'Tur',
    hideText: 'Gizle',
    // Listview
    backText: 'Geri',
    undoText: 'Geri Al',
    // Form
    offText: 'O',
    onText: 'I',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: '.'
  };

  // Vietnamese 
  mobiscroll.i18n.vi = {
    // Core
    setText: 't',
    cancelText: 'Hy b',
    clearText: 'Xa',
    selectedText: '{count} chn',
    // Datetime component
    dateFormat: 'dd/mm/yy',
    dayNames: ['Ch Nht', 'Th Hai', 'Th Ba', 'Th T', 'Th Nm', 'Th Su', 'Th By'],
    dayNamesShort: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
    dayNamesMin: ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'],
    dayText: '',
    delimiter: '/',
    hourText: 'Gi',
    minuteText: 'Pht',
    monthNames: ['Thng Mt', 'Thng Hai', 'Thng Ba', 'Thng T', 'Thng Nm', 'Thng Su', 'Thng By', 'Thng Tm', 'Thng Chn', 'Thng Mi', 'Thng Mi Mt', 'Thng Mi Hai'],
    monthNamesShort: ['Thng 1', 'Thng 2', 'Thng 3', 'Thng 4', 'Thng 5', 'Thng 6', 'Thng 7', 'Thng 8', 'Thng 9', 'Thng 10', 'Thng 11', 'Thng 12'],
    monthText: 'Thng',
    secText: 'Giy',
    timeFormat: 'H:ii',
    yearText: 'Nm',
    nowText: 'By gi',
    pmText: 'pm',
    amText: 'am',
    // Calendar component
    firstDay: 0,
    dateText: 'Ngy',
    timeText: 'Hi',
    todayText: 'Hm nay',
    prevMonthText: 'Thng trc',
    nextMonthText: 'Thng ti',
    prevYearText: 'Mm trc',
    nextYearText: 'Nm ti',
    closeText: 'ng',
    eventText: 'S kin',
    eventsText: 'S kin',
    allDayText: 'C ngy',
    noEventsText: 'Khng c s kin',
    moreEventsText: '{count} th khc',
    // Daterange component
    fromText: 'T',
    toText: 'Ti',
    // Measurement components
    wholeText: 'Ton th',
    fractionText: 'Phn s',
    unitText: 'n v',
    // Time / Timespan component
    labels: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
    labelsShort: ['Nm', 'Thng', 'Ngy', 'Gi', 'Pht', 'Giy', ''],
    // Timer component
    startText: 'Bt u',
    stopText: 'Dng',
    resetText: 't li',
    lapText: 'Vng',
    hideText: 'Giu',
    // Listview
    backText: 'Quay li',
    undoText: 'Hon tc',
    // Form
    offText: 'Tt',
    onText: 'Bt',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  // Chinese
  mobiscroll.i18n.zh = {
    // Core
    setText: '',
    cancelText: '',
    clearText: '',
    selectedText: '{count} ',
    // Datetime component
    dateFormat: 'yymmd',
    dayNames: ['', '', '', '', '', '', ''],
    dayNamesShort: ['', '', '', '', '', '', ''],
    dayNamesMin: ['', '', '', '', '', '', ''],
    dayText: '',
    hourText: '',
    minuteText: '',
    monthNames: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
    monthNamesShort: ['', '', '', '', '', '', '', '', '', '', '', ''],
    monthText: '',
    secText: '',
    timeFormat: 'HH:ii',
    yearText: '',
    nowText: '',
    pmText: '',
    amText: '',
    yearSuffix: '',
    monthSuffix: '',
    daySuffix: '',
    todayText: '',
    // Calendar component
    dateText: '',
    timeText: '',
    closeText: '',
    allDayText: '',
    noEventsText: '',
    eventText: '',
    eventsText: '',
    moreEventsText: ' {count} ',
    // Daterange component
    fromText: '',
    toText: '',
    // Measurement components
    wholeText: '',
    fractionText: '',
    unitText: '',
    // Time / Timespan component
    labels: ['', '', '', '', '', '', ''],
    labelsShort: ['', '', '', '', '', '', ''],
    // Timer component
    startText: '',
    stopText: '',
    resetText: '',
    lapText: '',
    hideText: '',
    // Listview
    backText: '',
    undoText: '',
    // Form
    offText: '',
    onText: '',
    // Numpad
    decimalSeparator: ',',
    thousandsSeparator: ' '
  };

  var themes$1 = mobiscroll.themes;
  themes$1.frame.ios = {
    display: 'bottom',
    // frame
    headerText: false,
    // frame
    btnWidth: false,
    // frame
    deleteIcon: 'ios-backspace',
    // numpad
    scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
  };
  themes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {
    rows: 5,
    // scroller
    height: 34,
    // scroller
    minWidth: 55,
    // scroller
    selectedLineHeight: true,
    // scroller
    selectedLineBorder: 1,
    // scroller
    showLabel: false,
    // scroller
    useShortLabels: true,
    // timespan/timer
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
    // scroller
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
    // scroller
    checkIcon: 'ion-ios7-checkmark-empty',
    // select
    filterClearIcon: 'ion-close-circled',
    // select
    dateDisplay: 'MMdyy',
    // date
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    // calendar
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar

  });
  themes$1.listview.ios = {
    leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
    rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
  };
  themes$1.form.ios = {};

  function _addRipple($control, ev) {
    var x = getCoord(ev, 'X', true),
        y = getCoord(ev, 'Y', true),
        control = $control[0],
        rect = $control.offset(),
        left = x - rect.left,
        top = y - rect.top,
        width = Math.max(left, control.offsetWidth - left),
        height = Math.max(top, control.offsetHeight - top),
        size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

    _removeRipple($ripple);

    $ripple = $$1('<span class="mbsc-ripple"></span>').css({
      backgroundColor: getComputedStyle(control).color,
      width: size,
      height: size,
      top: y - rect.top - size / 2,
      left: x - rect.left - size / 2
    }).appendTo($control);
    setTimeout(function () {
      $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
    }, 10);
  }

  function _removeRipple($r) {
    setTimeout(function () {
      if ($r) {
        $r.removeClass('mbsc-ripple-visible');
        setTimeout(function () {
          $r.remove();
        }, 2000);
      }
    }, 100);
  }

  function initRipple($markup, selector, disabled, nohl) {
    var startX,
        startY,
        markup = $markup[0];

    function onStart(ev) {
      var target = closest(markup, ev.target, selector);

      if (target && testTouch(ev, target)) {
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        $active$1 = $$1(target);

        if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
          _addRipple($active$1, ev);
        } else {
          $active$1 = null;
        }
      }
    }

    function onMove(ev) {
      if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
        _removeRipple($ripple);

        $active$1 = null;
      }
    }

    function onEnd() {
      if ($active$1) {
        setTimeout(function () {
          _removeRipple($ripple);
        }, 100);
        $active$1 = null;
      }
    }

    if (markup) {
      if (markup.__mbscRippleOff) {
        markup.__mbscRippleOff();
      }

      listen(markup, 'touchstart', onStart, {
        passive: true
      });
      listen(markup, 'mousedown', onStart);
      listen(markup, 'touchmove', onMove, {
        passive: true
      });
      listen(markup, 'mousemove', onMove);
      listen(markup, 'touchend', onEnd);
      listen(markup, 'touchcancel', onEnd);
      listen(markup, 'mouseleave', onEnd);
      listen(markup, 'mouseup', onEnd);

      markup.__mbscRippleOff = function () {
        unlisten(markup, 'touchstart', onStart, {
          passive: true
        });
        unlisten(markup, 'mousedown', onStart);
        unlisten(markup, 'touchmove', onMove, {
          passive: true
        });
        unlisten(markup, 'mousemove', onMove);
        unlisten(markup, 'touchend', onEnd);
        unlisten(markup, 'touchcancel', onEnd);
        unlisten(markup, 'mouseleave', onEnd);
        unlisten(markup, 'mouseup', onEnd);
        delete markup.__mbscRippleOff;
      };
    }
  }

  var $active$1,
      $ripple,
      themes$2 = mobiscroll.themes;
  themes$2.frame.material = {
    headerText: false,
    btnWidth: false,
    deleteIcon: 'material-backspace',
    onMarkupReady: function onMarkupReady(ev) {
      initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
    }
  };
  themes$2.scroller.material = extend$1({}, themes$2.frame.material, {
    showLabel: false,
    selectedLineBorder: 2,
    weekDays: 'min',
    icon: {
      filled: 'material-star',
      empty: 'material-star-outline'
    },
    checkIcon: 'material-check',
    btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
    btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
    btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
    btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
  });
  themes$2.listview.material = {
    leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
    rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
    onItemActivate: function onItemActivate(ev) {
      _addRipple($$1(ev.target), ev.domEvent);
    },
    onItemDeactivate: function onItemDeactivate() {
      _removeRipple($ripple);
    },
    onSlideStart: function onSlideStart(ev) {
      $$1('.mbsc-ripple', ev.target).remove();
    },
    onSortStart: function onSortStart(ev) {
      $$1('.mbsc-ripple', ev.target).remove();
    }
  };
  themes$2.navigation.material = {
    onInit: function onInit() {
      initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
    },
    onMarkupInit: function onMarkupInit() {
      $$1('.mbsc-ripple', this).remove();
    },
    onDestroy: function onDestroy() {
      if (this.__mbscRippleOff) {
        this.__mbscRippleOff();
      }
    }
  };
  themes$2.form.material = {
    addRipple: function addRipple(elm, ev) {
      _addRipple(elm, ev);
    },
    removeRipple: function removeRipple() {
      _removeRipple($ripple);
    }
  };

  var themes$3 = mobiscroll.themes;
  themes$3.frame.windows = {
    headerText: false,
    deleteIcon: 'backspace4',
    //setIcon: 'material-check',
    //cancelIcon: 'material-close',
    //closeIcon: 'material-close',
    //clearIcon: 'material-close',
    //okIcon: 'material-check',
    //nowIcon: 'loop2',
    //startIcon: 'play3',
    //stopIcon: 'pause2',
    //resetIcon: 'stop2',
    //lapIcon: 'loop2',
    //btnWidth: false,
    btnReverse: true
  };
  themes$3.scroller.windows = extend$1({}, themes$3.frame.windows, {
    rows: 6,
    // scroller
    minWidth: 88,
    height: 44,
    btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
    btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
    checkIcon: 'material-check',
    dateDisplay: 'MMdyy',
    // date
    showLabel: false,
    showScrollArrows: true,
    btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
    // calendar
    btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',
    // calendar
    dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    useShortLabels: true // timespan/timer

  });
  themes$3.form.windows = {};

  mobiscroll.customTheme('ios-dark', 'ios');

  mobiscroll.customTheme('material-dark', 'material');

  mobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');

  mobiscroll.customTheme('windows-dark', 'windows');

  var themes$4 = mobiscroll.themes;
  var theme = 'mobiscroll';

  if (os == 'android') {
    theme = 'material';
  } else if (os == 'ios') {
    theme = 'ios';
  } else if (os == 'wp') {
    theme = 'windows';
  }

  $$1.each(themes$4.frame, function (key, settings) {
    // Stop at the first custom theme with the OS base theme
    if (theme && settings.baseTheme == theme && key != theme + '-dark') {
      mobiscroll.autoTheme = key;
      return false;
    } else if (key == theme) {
      mobiscroll.autoTheme = key;
    }
  });

  return mobiscroll;

})));

//# sourceMappingURL=mobiscroll.react.js.map